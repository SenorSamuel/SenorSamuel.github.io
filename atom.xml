<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Samuel blog</title>
  <subtitle>SamuelChan</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-07-19T11:24:27.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>SamuelChan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/07/19/hello-world/"/>
    <id>http://yoursite.com/2017/07/19/hello-world/</id>
    <published>2017-07-19T03:44:34.000Z</published>
    <updated>2017-07-19T11:24:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
      <category term="test" scheme="http://yoursite.com/categories/test/"/>
    
    
  </entry>
  
  <entry>
    <title>Pro.Multithreading.and.Memory.Management.for.iOS.and.OS.X(MRC和ARC)</title>
    <link href="http://yoursite.com/2017/07/06/Pro.Multithreading.and.Memory.ManageMent.for.iOS.and.OS.X/"/>
    <id>http://yoursite.com/2017/07/06/Pro.Multithreading.and.Memory.ManageMent.for.iOS.and.OS.X/</id>
    <published>2017-07-06T06:56:56.000Z</published>
    <updated>2017-07-20T02:11:16.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Problems:  </p>
<ol>
<li>一个非alloc/new/copy/muteCopy返回对象的方法应该由谁管理内存?  </li>
<li>AutoReleasePool也需要进行内存管理吗?如果要,谁来管理?</li>
</ol>
</blockquote>
<h2 id="Pro-Multithreading-and-Memory-Management-for-iOS-and-OS-X"><a href="#Pro-Multithreading-and-Memory-Management-for-iOS-and-OS-X" class="headerlink" title="Pro.Multithreading.and.Memory.Management.for.iOS.and.OS.X"></a>Pro.Multithreading.and.Memory.Management.for.iOS.and.OS.X</h2><hr>
<h3 id="Chapter1-Life-Before-Automatic-Reference-Counting"><a href="#Chapter1-Life-Before-Automatic-Reference-Counting" class="headerlink" title="Chapter1 Life Before Automatic Reference Counting"></a>Chapter1 Life Before Automatic Reference Counting</h3><hr>
<h4 id="Reference-Counted-Memory-Management-Overview"><a href="#Reference-Counted-Memory-Management-Overview" class="headerlink" title="Reference Counted Memory Management Overview"></a>Reference Counted Memory Management Overview</h4><ol>
<li>Memory Management(means Reference Counting in OC) : a programmer allocates a memory area when the program needs it and frees it when the program no longer needs it.  </li>
<li>Reference Counting: invented by George E. Collins in 1960</li>
<li>With Reference Counting,you don’t need to remember the value of the reference counter itself or what refers to the object<br><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170706152431.png" alt="SamuelChan/20170706152431.png"></li>
</ol>
<h4 id="Exploring-Memory-Management-Further"><a href="#Exploring-Memory-Management-Further" class="headerlink" title="Exploring Memory Management Further"></a>Exploring Memory Management Further</h4><ol>
<li>Reference Counting Rules:<ul>
<li>You have ownership of any objects you create.</li>
<li>You can take ownership of an object using retain.</li>
<li>When no longer needed, you must relinquish ownership of an object you own.</li>
<li>You must not relinquish ownership of an object you don’t own.</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>Action for Objective-C Object</th>
<th>Objective-C Method</th>
</tr>
</thead>
<tbody>
<tr>
<td>Create and have ownership of it</td>
<td>alloc/new/copy/mutableCopy group</td>
</tr>
<tr>
<td>Take ownership of it</td>
<td>retain</td>
</tr>
<tr>
<td>Relinquish it</td>
<td>release</td>
</tr>
<tr>
<td>Dispose of it</td>
<td>dealloc</td>
</tr>
</tbody>
</table>
<blockquote>
<p>these method(alloc, retain, release, and dealloc) are not provided by the Objective-C language itself.They are features of the Foundation Framework as part of Cocoa Framework<br><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170706154549.png" alt="SamuelChan/20170706154549.png"></p>
</blockquote>
<h5 id="You-Have-Ownership-of-Any-Objects-You-Create"><a href="#You-Have-Ownership-of-Any-Objects-You-Create" class="headerlink" title="You Have Ownership of Any Objects You Create"></a>You Have Ownership of Any Objects You Create</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// You create an object and have ownership.</div><div class="line">id obj     = [[NSObject alloc] init];</div><div class="line">id obj     = [NSObject new];</div><div class="line">id objNew1 = [obj copy];//NSCopying protocol:copyWithZone:</div><div class="line">id objNew2 = [obj mutableCopy];//NSMutableCopying protocol:mutableCopyWithZone:</div><div class="line">//the naming convention is applied to:</div><div class="line">  allocMyObject newThatObject copyThis mutableCopyYourObject</div><div class="line">//the naming convention is not applied to:</div><div class="line">  allocate  newer  copying  mutableCopyed</div></pre></td></tr></table></figure>
<h5 id="You-Can-Take-Ownership-of-an-Object-Using-retain"><a href="#You-Can-Take-Ownership-of-an-Object-Using-retain" class="headerlink" title="You Can Take Ownership of an Object Using retain"></a>You Can Take Ownership of an Object Using retain</h5><p>Sometimes methods that are not in the alloc/new/copy/mutableCopy<br>method group return an object : you haven’t create it,<br>so you don’t have ownership of it.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Obtain an object without creating it yourself or having ownership   </span></div><div class="line"></div><div class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"><span class="comment">// The obtained object exists and you don’t have ownership of it,but you have a reference to NSMutableArray object.</span></div><div class="line"></div><div class="line">[obj <span class="keyword">retain</span>];</div><div class="line"><span class="comment">// The obtained object exists and you don’t have ownership of it.</span></div></pre></td></tr></table></figure>
<h5 id="When-No-Longer-Needed-You-Must-Relinquish-Ownership-of-an-Object-You-Own"><a href="#When-No-Longer-Needed-You-Must-Relinquish-Ownership-of-an-Object-You-Own" class="headerlink" title="When No Longer Needed, You Must Relinquish Ownership of an Object You Own"></a>When No Longer Needed, You Must Relinquish Ownership of an Object You Own</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1.alloc -&gt; relinquish</span></div><div class="line"><span class="comment">// You create an object and have ownership.</span></div><div class="line">id obj = [[NSObject alloc] init];</div><div class="line"><span class="comment">// Now you have ownership of the object.</span></div><div class="line">[obj release];</div><div class="line"><span class="comment">// The object is relinquished.Though the variable obj has the pointer to the object,you can’t access the object anymore.</span></div><div class="line"></div><div class="line"><span class="comment">// 2.retain -&gt; relinquish</span></div><div class="line"><span class="comment">// Obtain an object without creating it yourself or having ownership</span>id obj = [NSMutableArray <span class="keyword">array</span>];<span class="comment">// The obtained object exists and you don’t have ownership of it.</span>[obj retain];<span class="comment">// Now you have ownership of the object.</span>[obj release];<span class="comment">// The object is relinquished.You can’t access the object anymore.</span></div></pre></td></tr></table></figure>
<p><em>how a method return a created object?</em>  </p>
<ol>
<li>alloc/new/copy/muteableCopy : <strong>If a method returns an object of which the method has ownership, ownership is passed to the caller</strong></li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)allocObject &#123;  <span class="comment">// You create an object and have ownership.  </span>	<span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];  <span class="comment">// At this moment, this method has ownership of the object.  </span>	<span class="keyword">return</span> obj;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.[NSMutableArray array] : Returning a New Object Without Ownership.<strong>By calling autorelease, you can return the created object without ownership</strong> 可以返回,而不是为什么要返回没有ownership的(means by design)</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (id)<span class="keyword">object</span> &#123;	id obj = [[<span class="type">NSObject</span> alloc] init];/* <span class="type">At</span> this moment, this <span class="keyword">method</span> has ownership <span class="keyword">of</span> the <span class="keyword">object</span>. */	[obj autorelease];/* <span class="type">The</span> <span class="keyword">object</span> exists, <span class="keyword">and</span> you don’t have ownership <span class="keyword">of</span> it. */<span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170706173000.png" alt="SamuelChan/20170706173000.png"></p>
<h5 id="You-Must-Not-Relinquish-Ownership-of-an-Object-You-Don’t-Own"><a href="#You-Must-Not-Relinquish-Ownership-of-an-Object-You-Don’t-Own" class="headerlink" title="You Must Not Relinquish Ownership of an Object You Don’t Own"></a>You Must Not Relinquish Ownership of an Object You Don’t Own</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">[obj release];</div><div class="line">[obj release];<span class="comment">//crash</span></div><div class="line"></div><div class="line"><span class="keyword">id</span> obj1 = [obj0 object];</div><div class="line">[obj1 release];<span class="comment">//crash sooner or later</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/** why retainCount = -1 ? */</span></div><div class="line"><span class="keyword">id</span> obj2 = [<span class="built_in">NSArray</span> array];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,[obj2 retainCount]);</div><div class="line"></div><div class="line"><span class="keyword">id</span> obj4 = [<span class="built_in">NSString</span> string];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,[obj4 retainCount]);</div></pre></td></tr></table></figure>
<h4 id="Implementing-alloc-retain-release-and-dealloc"><a href="#Implementing-alloc-retain-release-and-dealloc" class="headerlink" title="Implementing alloc, retain, release, and dealloc"></a>Implementing alloc, retain, release, and dealloc</h4><p>Although opensourced, I think this <code>guess</code> procedure still worth of being read so HERE WE GO.  </p>
<p>1.<del> But still, without having the implementation of NSObject itself, it is hard to see the whole picture </del>  :   <a href="https://github.com/opensource-apple/objc4" target="_blank" rel="external">NSObject has been opensource</a><br>2.CFFoundation is open-source,and the source code for memory management that is used from NSObject is public  </p>
<ol>
<li><a href="https://en.wikipedia.org/wiki/GNUstep" target="_blank" rel="external">GNUstep</a> is a free software implementation of the Cocoa (formerly OpenStep) Objective-C frameworks, widget toolkit, and application development tools for Unix-like operating systems and Microsoft Windows. It is part of the GNU Project.Although we can’t expect it to be exactly the same as Apple’s implementation, it works in the same manner and the implementation should be similar.<strong>Understanding GNUstep source code helps us guess Apple’s Cocoa implementation</strong></li>
</ol>
<h5 id="GNUStep-implementation"><a href="#GNUStep-implementation" class="headerlink" title="GNUStep implementation"></a>GNUStep implementation</h5><p>1.The alloc Method</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> obj_layout &#123;</div><div class="line">	<span class="built_in">NSUInteger</span> retained;&#125;;+ (<span class="keyword">id</span>) alloc &#123;	<span class="keyword">int</span> size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> obj_layout) + size_of_the_object;</div><div class="line">	<span class="comment">//在堆上，分配n*size个字节，并初始化为0，返回void* 类型</span></div><div class="line">	<span class="keyword">struct</span> obj_layout *p = (<span class="keyword">struct</span> obj_layout *)calloc(<span class="number">1</span>, size);</div><div class="line">	<span class="keyword">return</span> (<span class="keyword">id</span>)(p + <span class="number">1</span>);&#125;</div></pre></td></tr></table></figure>
<p>2.The retain Method<br><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170707105639.png" alt="SamuelChan/20170707105639.png"></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSUInteger</span>) retainCount &#123;	<span class="keyword">return</span> <span class="built_in">NSExtraRefCount</span>(<span class="keyword">self</span>) + <span class="number">1</span>;</div><div class="line">&#125;<span class="keyword">inline</span> <span class="built_in">NSUInteger</span> <span class="built_in">NSExtraRefCount</span>(<span class="keyword">id</span> anObject)&#123;</div><div class="line">	<span class="keyword">return</span> ((<span class="keyword">struct</span> obj_layout *)anObject)[<span class="number">-1</span>].retained; <span class="comment">//移到头部</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>) <span class="keyword">retain</span> &#123;	<span class="built_in">NSIncrementExtraRefCount</span>(<span class="keyword">self</span>);    <span class="keyword">return</span> <span class="keyword">self</span>;&#125;<span class="keyword">inline</span> <span class="keyword">void</span> <span class="built_in">NSIncrementExtraRefCount</span>(<span class="keyword">id</span> anObject) &#123;	<span class="keyword">if</span> (((<span class="keyword">struct</span> obj_layout *)anObject)[<span class="number">-1</span>].retained == <span class="built_in">UINT_MAX</span> - <span class="number">1</span>)</div><div class="line">	[<span class="built_in">NSException</span> raise: <span class="built_in">NSInternalInconsistencyException</span>format: <span class="string">@"NSIncrementExtraRefCount() asked to increment too far"</span>];</div><div class="line">	((<span class="keyword">struct</span> obj_layout *)anObject)[<span class="number">-1</span>].retained++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3.The release Method</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>) release &#123;	<span class="keyword">if</span> (<span class="built_in">NSDecrementExtraRefCountWasZero</span>(<span class="keyword">self</span>))	[<span class="keyword">self</span> dealloc]; <span class="comment">//dispose it</span></div><div class="line">&#125;<span class="built_in">BOOL</span> <span class="built_in">NSDecrementExtraRefCountWasZero</span>(<span class="keyword">id</span> anObject) &#123;	<span class="keyword">if</span> (((<span class="keyword">struct</span> obj_layout *)anObject)[<span class="number">-1</span>].retained == <span class="number">0</span>) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">YES</span>;	&#125; <span class="keyword">else</span> &#123;		((<span class="keyword">struct</span> obj_layout *)anObject)[<span class="number">-1</span>].retained--;</div><div class="line">		<span class="keyword">return</span> <span class="literal">NO</span>;	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>4.The dealloc Method</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>) dealloc &#123;	<span class="built_in">NSDeallocateObject</span> (<span class="keyword">self</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="built_in">NSDeallocateObject</span>(<span class="keyword">id</span> anObject) &#123;	<span class="keyword">struct</span> obj_layout *o = &amp;((<span class="keyword">struct</span> obj_layout *)anObject)[<span class="number">-1</span>];	free(o);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Apple’s-Implementation-of-alloc-retain-release-and-dealloc"><a href="#Apple’s-Implementation-of-alloc-retain-release-and-dealloc" class="headerlink" title="Apple’s Implementation of alloc, retain, release, and dealloc"></a>Apple’s Implementation of alloc, retain, release, and dealloc</h5><p>1.The alloc method</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="addition">+alloc</span></div><div class="line"><span class="addition">+allocWithZone:</span></div><div class="line">class_createInstance</div><div class="line">calloc</div></pre></td></tr></table></figure>
<p>2.retainCount, retain, and release</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">-retainCount</div><div class="line">__CFDoExternRefOperation<span class="built_in">CFBasicHashGetCountOfKey</span></div><div class="line">-<span class="keyword">retain</span></div><div class="line">__CFDoExternRefOperation</div><div class="line"><span class="built_in">CFBasicHashAddValue</span></div><div class="line"></div><div class="line">-release</div><div class="line">__CFDoExternRefOperation</div><div class="line"><span class="built_in">CFBasicHashRemoveValue</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> __CFDoExternRefOperation(uintptr_t op, <span class="keyword">id</span> obj) &#123;</div><div class="line">	<span class="built_in">CFBasicHashRef</span> table = get hashtable from obj;</div><div class="line">	<span class="keyword">int</span> count;	<span class="keyword">switch</span> (op) &#123;	<span class="keyword">case</span> OPERATION_retainCount:		count = <span class="built_in">CFBasicHashGetCountOfKey</span>(table, obj);</div><div class="line">		<span class="keyword">return</span> count;	<span class="keyword">case</span> OPERATION_retain:</div><div class="line">		<span class="built_in">CFBasicHashAddValue</span>(table, obj);</div><div class="line">		<span class="keyword">return</span> obj;	<span class="keyword">case</span> OPERATION_release:		count = <span class="built_in">CFBasicHashRemoveValue</span>(table, obj);</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span> == count;	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="built_in">NSUInteger</span>) retainCount &#123;	<span class="keyword">return</span> (<span class="built_in">NSUInteger</span>)__CFDoExternRefOperation(OPERATION_retainCount, <span class="keyword">self</span>);</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">id</span>) <span class="keyword">retain</span> &#123;<span class="keyword">return</span> (<span class="keyword">id</span>)__CFDoExternRefOperation(OPERATION_retain, <span class="keyword">self</span>);</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>) release &#123;<span class="keyword">return</span> __CFDoExternRefOperation(OPERATION_release, <span class="keyword">self</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3.Apple implementation vs GNUStep implementation<br>Benefits:<br>GNUStep implementation:    </p>
<ul>
<li>Fewer codes  </li>
<li>It is quite simple to manage the lifetime, because each memory area of the reference count itself is included in the object memory area</li>
</ul>
<p>Apple implementation:</p>
<ul>
<li>Each object doesn’t have a header, thus there is no need to worry about alignment issues for the header area</li>
<li>By iterating through the hash table entries, memory blocks for each object are reachable.(useful for debugging,LLDB and Instruments)</li>
</ul>
<p><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170707113104.png" alt="SamuelChan/20170707113104.png"><br><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170707113946.png" alt="SamuelChan/20170707113946.png"></p>
<h4 id="Autorelease"><a href="#Autorelease" class="headerlink" title="Autorelease"></a>Autorelease</h4><p>1.Automatic Variables in C language:when left the variable scope,auto variable ‘int a’ is disposed of and can’t be accessed anymore.<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&#123;	int a;  &#125;</span></div><div class="line">```  </div><div class="line"><span class="number">2</span>.autoRelease:when execution leaves a code <span class="keyword">block</span>, the “release” <span class="function"><span class="keyword">method</span> <span class="title">is</span> <span class="title">called</span> <span class="title">on</span> <span class="title">the</span> <span class="title">object</span> <span class="title">automatically</span></span></div><div class="line"></div><div class="line">3.<span class="title">Caution</span>:  </div><div class="line">(<span class="number">1</span>)临时处理多个对象的释放  </div><div class="line">(<span class="number">2</span>)类方法返回来一个没有ownership的对象  </div><div class="line">(<span class="number">3</span>)不要对NSAutoReleasePool发送autoRelease方法,因为它已经被<span class="keyword">override</span>抛出exception</div></pre></td></tr></table></figure></p>
<p>//1. Create an NSAutoreleasePool object.<br>NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];</p>
<p>//2. Call “autorelease” to allocated objects.<br>id obj = [[NSObject alloc] init];<br>[obj autorelease];</p>
<p>//3. Discard the NSAutoreleasePool object.<br>[pool drain];//will do [obj release]</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">![<span class="string">SamuelChan/20170707141849.png</span>](<span class="link">http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170707141849.png</span>)  </div><div class="line"></div><div class="line">No need to explicitly use the NSAutoreleasePool object in <span class="code">`the main Runloop`</span></div></pre></td></tr></table></figure>
<p>@autoreleasepool {<br>        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));<br>    }<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">![<span class="string">SamuelChan/20170707142124.png</span>](<span class="link">http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170707142124.png</span>)  </div><div class="line"></div><div class="line"><span class="section">##### Implementing autorelease</span></div></pre></td></tr></table></figure></p>
<p>class AutoreleasePoolPage {<br>    static inline void <em>push() {<br>    /</em> It corresponds to creation and ownership of an NSAutoreleasePool object */<br>    }</p>
<pre><code>static inline void pop(void *token) {
/* It corresponds to disposal of an NSAutoreleasePool object */
releaseAll();
}

static inline id autorelease(id obj) {
/* It corresponds to NSAutoreleasePool class method addObject. */
    AutoreleasePoolPage *autoreleasePoolPage = /* getting active     AutoreleasePoolPage object */
    autoreleasePoolPage-&gt;add(obj);
}

id *add(id obj) {
/* add the obj to an internal array; */ }

void releaseAll() {
/* calls release for all the objects in the internal array */ }
};

void *objc_autoreleasePoolPush(void) {
    return AutoreleasePoolPage::push();
}

void objc_autoreleasePoolPop(void *ctxt) {
    AutoreleasePoolPage::pop(ctxt);
}
id objc_autorelease(id obj) {
    return AutoreleasePoolPage::autorelease(obj);
}
</code></pre><p>}<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">---</span></div><div class="line"><span class="comment">### Chapter2 ARC Rules</span></div><div class="line"><span class="comment">---</span></div><div class="line">&gt; Apple: Automatic Reference Counting (ARC) <span class="keyword">in</span> Objective-C makes memory management <span class="keyword">the</span> job <span class="keyword">of</span> <span class="keyword">the</span> compiler. By enabling ARC <span class="keyword">with</span> <span class="keyword">the</span> <span class="built_in">new</span> Apple LLVM compiler, you will never need <span class="built_in">to</span> type retain <span class="keyword">or</span> release again, dramatically simplifying <span class="keyword">the</span> development <span class="built_in">process</span>, <span class="keyword">while</span> reducing crashes <span class="keyword">and</span> memory leaks. The compiler has <span class="keyword">a</span> complete understanding <span class="keyword">of</span> your objects, <span class="keyword">and</span> releases <span class="keyword">each</span> object <span class="keyword">the</span> instant <span class="keyword">it</span> is no longer used, so apps run <span class="keyword">as</span> fast <span class="keyword">as</span> ever, <span class="keyword">with</span> predictable, smooth performance<span class="number">.1</span></div><div class="line"></div><div class="line">ARC related:</div><div class="line"></div><div class="line">- iOS <span class="number">5</span> <span class="number">2011</span>  </div><div class="line">- Xcode Version &gt;= <span class="number">4.2</span>  </div><div class="line">- LLVM <span class="built_in">version</span>  &gt;= <span class="number">3.0</span>  </div><div class="line">- Objective-C runtime library: objc4 <span class="number">493.9</span> <span class="keyword">or</span> later</div><div class="line">- ARC enabled: <span class="number">1.</span>Enabled ARC <span class="keyword">in</span> build Setting <span class="number">2.</span>部分MRC:Build phases→Compile Sources→ -fno-objc-arc <span class="number">3.</span> Build phases→Compile Sources→部分ARC:-fobjc-arc   </div><div class="line">![SamuelChan/<span class="number">20170717103437.</span>png](<span class="keyword">http</span>://ormqbgzmy.bkt.clouddn.com/SamuelChan/<span class="number">20170717103437.</span>png)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">Chapter2组织方式:</div></pre></td></tr></table></figure></p>
<ul>
<li>the relationship of the reference counting rules with ARC  </li>
<li>the ownership specifiers one by one  </li>
<li>we learn the rules to make your code ARC-friendly: by simply  following the rules<figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#### Ownership qualifiers</div><div class="line">&gt; With ARC,, ‘id’ and object type variables &lt;mark&gt;**must**&lt;/mark&gt; have one <span class="keyword">of</span> the following four ownership qualifiers:</div><div class="line"></div><div class="line">- __strong  - __weak  - __unsafe _unretained     </div><div class="line">- __autoreleasing</div><div class="line"></div><div class="line">##### <span class="number">1.</span>__strong ownership qualifier</div><div class="line"></div><div class="line">- __strong 代表了对象的ownership (MRC下对象需要通过alloc/new/copy/muteableCopy或者retain来获得ownership)</div><div class="line"></div><div class="line">- __strong离开了&#123; &#125;之后就会消失,即是说作用域在&#123; &#125;之间</div><div class="line"></div><div class="line">- 一个对象没有ownership将会被disposed</div></pre></td></tr></table></figure>
</li>
</ul>
<p>/<em> non-ARC </em>/<br>{<br>     id obj = [[NSObject alloc] init];<br>    [obj release];<br>}<br>/<em> ARC </em>/<br>{<br>    id __strong obj = [[NSObject alloc] init];<br>}</p>
<p>{<br>    id __strong obj = [NSMutableArray array];<br>}</p>
<p>//ownership is properly managed not only by variable scope, but also by assignments between variables<br>id <strong>strong obj0 = [[NSObject alloc] init];<br>id </strong>strong obj1 = [[NSObject alloc] init];<br>id __strong obj2 = nil;<br>obj0 = obj1;<br>obj2 = obj0;<br>obj1 = nil;<br>obj0 = nil;<br>obj2 = nil;</p>
<p>//By the way, any variables that are qualified with <strong>strong, </strong>weak, and <strong>autoreleasing, are initialized with nil<br>id </strong>strong obj0;<br>id <strong>weak obj1;<br>id </strong>autoreleasing obj2;<br>The above source code is equivalent to the following.<br>id <strong>strong obj0 = nil;<br>id </strong>weak obj1 = nil;<br>id __autoreleasing obj2 = nil;<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">#####2.__weak ownership qualifier</span></div><div class="line">&gt; solve circular reference,self reference: A weak reference does <span class="keyword">not</span> have ownership <span class="keyword">of</span> <span class="keyword">the</span> object.</div><div class="line"></div><div class="line">&gt; When <span class="keyword">a</span> <span class="built_in">variable</span> has <span class="keyword">a</span> reference <span class="built_in">to</span> <span class="keyword">an</span> object <span class="keyword">and</span> <span class="keyword">the</span> object is discarded, <span class="keyword">the</span> weak reference also disappears automatically, which means that <span class="keyword">the</span> <span class="built_in">variable</span> is assigned <span class="built_in">to</span> &lt;mark&gt;nil&lt;/mark&gt;.</div><div class="line"></div><div class="line">![SamuelChan/<span class="number">20170711111007.</span>png](<span class="keyword">http</span>://ormqbgzmy.bkt.clouddn.com/SamuelChan/<span class="number">20170711111007.</span>png)</div></pre></td></tr></table></figure></p>
<p>id __weak obj = [[NSObject alloc] init];//wrong,<br>//warning: assigning retained obj to weak variable; obj will be released after assignment [-Warc-unsafe-retained-assign]</p>
<p>id <strong>strong obj0 = [[NSObject alloc] init];<br>id </strong>weak obj1 = obj0;<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#####<span class="number">3.</span>__unsafe_unretained ownership qualifier</div></pre></td></tr></table></figure></p>
<p><strong>weak               : iOS5 (or later) or OSX Lion (or later)
</strong>unsafe _unretained : before iOS5 or before OSX Lion</p>
<p>//<strong>weak和</strong>unsafe_unretained的区别在于:后者不会在对象无ownership之后自动置为nil<br>id <strong>unsafe_unretained obj1 = nil;<br>{<br>    id </strong>strong obj0 = [[NSObject alloc] init];<br>    obj1 = obj0;<br>    NSLog(@”A: %@”, obj1);<br>}<br>    NSLog(@”B: %@”, obj1);//Crash:野指针,访问僵尸对象,报EXC_BAD_ADDRESS</p>
<p>FYI:<br>（1）野指针<br>①C语言:定义了一个指针变量，但是并没有赋初值，它随机指向一个东西<br>②Obj某指针变量指向的内存空间被释放掉了（指向僵尸对象的指针）</p>
<p>（2）僵尸对象<br>已经被销毁的对象（无法被使用的对象）</p>
<p>（3）空指针<br>没有指向存储空间的指针（里面存的是nil，也就是0）<br>给空指针发消息是没有任何反应的，不会提示出错</p>
<p>(4) EXC_BAD_ADDRESS ARC什么时候会出现?? Core-Foundation,混编,C++</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="section">#####4.__autoreleasing ownership qualifier</span></div><div class="line">![<span class="string">SamuelChan/20170711144133.png</span>](<span class="link">http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170711144133.png</span>)</div><div class="line">![<span class="string">SamuelChan/20170711144249.png</span>](<span class="link">http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170711144249.png</span>)</div><div class="line"></div><div class="line"><span class="bullet">- </span>①When an object is returned from a method, the compiler checks if the method begins with alloc/new/copy/mutableCopy, and if not, the returned object is automatically registered to the autorelease pool</div><div class="line"></div><div class="line"><span class="bullet">- </span>②Exceptionally, any method whose name begins with init, doesn’t register the return value to autoreleasepool</div></pre></td></tr></table></figure>
<p>@autoreleasepool {<br>//not in the alloc/new/copy/mutableCopy method group,register in autoReleasePool<br>    id __strong obj = [NSMutableArray array];<br>}</p>
<p>//“id obj” does not have a qualifier. So it is qualified with<br>__strong. When the “return” sentence is executed, the variable scope<br>is left and the strong reference disappears. Therefore the object will<br> be released automatically. Before that, if the compiler detects that<br>  the object will be passed to the caller, the object is registered in autoreleasepool.</p>
<ul>
<li>(id) array {<br>  id obj = [[NSMutableArray alloc] init];<br>  return obj;<br>}</li>
</ul>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- ③&lt;del&gt;<span class="keyword">the</span> __weak ownership qualifier is used <span class="built_in">to</span> avoid cyclic reference. When <span class="keyword">a</span> <span class="built_in">variable</span> <span class="keyword">with</span> <span class="keyword">a</span> __weak qualifier is used, <span class="keyword">the</span> object is always registered <span class="keyword">in</span> autoreleasepool.&lt;/del&gt;  </div><div class="line"></div><div class="line">	&lt;del&gt; Why does <span class="keyword">the</span> object need <span class="built_in">to</span> be registered <span class="keyword">in</span> autoreleasepool <span class="keyword">in</span> order <span class="built_in">to</span> use <span class="keyword">the</span> object via <span class="keyword">the</span> __weak qualified <span class="built_in">variable</span>? Because <span class="keyword">a</span> <span class="built_in">variable</span>, which is qualified <span class="keyword">with</span> __weak,</div><div class="line"> does <span class="keyword">not</span> have <span class="keyword">a</span> strong reference, <span class="keyword">the</span> object might be disposed <span class="keyword">of</span> <span class="keyword">at</span> <span class="keyword">any</span> point. If <span class="keyword">the</span> object is registered <span class="keyword">in</span> autoreleasepool, <span class="keyword">until</span> @autoreleasepool block is left, <span class="keyword">the</span> object must exist. So, <span class="built_in">to</span> use <span class="keyword">the</span> objects via __weak <span class="built_in">variable</span> safely, <span class="keyword">the</span> object is registered <span class="keyword">in</span> autoreleasepool automatically.(**<span class="built_in">to</span> be proved**) &lt;/del&gt;</div><div class="line"></div><div class="line">- ④ Any pointers <span class="built_in">to</span> ‘id’ <span class="keyword">or</span> object types are qualified <span class="keyword">with</span> __autoreleasing <span class="keyword">as</span> default.</div></pre></td></tr></table></figure>
<p>id obj            == id <strong>strong obj;<br>id *obj          == id </strong>autoreleasing <em>obj;<br>NSObject **obj == NSObject </em> <strong>autoreleasing <em>obj<br>-(BOOL) performOperationWithError:(NSError </em> </strong>autoreleasing *)error;</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="number">5.</span>Returning <span class="keyword">a</span> Result <span class="keyword">as</span> <span class="keyword">the</span> Argument</div><div class="line">&gt;The caller will obtain <span class="keyword">the</span> object <span class="keyword">as</span> <span class="keyword">an</span> argument, which means that <span class="keyword">the</span> caller does <span class="keyword">not</span> obtain <span class="keyword">it</span> <span class="built_in">from</span> <span class="keyword">the</span> alloc/<span class="built_in">new</span>/copy/mutableCopy method group. To follow <span class="keyword">the</span> memory management rules, &lt;mark&gt;when you <span class="built_in">do</span> <span class="keyword">not</span> obtain <span class="keyword">an</span> object <span class="keyword">by</span> <span class="keyword">the</span> alloc/<span class="built_in">new</span>/copy/mutableCopy method group, <span class="keyword">the</span> object has <span class="built_in">to</span> be passed <span class="keyword">without</span> ownership.&lt;/mark&gt; By <span class="keyword">the</span> __autoreleasing ownership qualifier, <span class="keyword">the</span> rule is fulfilled.</div></pre></td></tr></table></figure>
<ul>
<li>(BOOL) performOperationWithError:(NSError <em> __autoreleasing </em>)error {<br>  /<em> Error occurred. Set errorCode </em>/<br>  return NO;<br>}</li>
</ul>
<p>//To assign an object pointer, both ownership qualifiers have to be the same.<br>NSError <strong>autoreleasing <em>error = nil;<br>NSError </em> </strong>autoreleasing <em>pError = &error; /</em> No compile error */</p>
<p>//compile optimization(before)<br>NSError __strong *error = nil;<br>BOOL result = [obj performOperationWithError:&amp;error];</p>
<p>//compile optimization(after)<br>NSError <strong>strong *error = nil;<br>NSError </strong>autoreleasing *tmp = error;<br>BOOL result = [obj performOperationWithError:&amp;tmp];<br>error = tmp;</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### Rules</div></pre></td></tr></table></figure>
<p> 1.Forget about using retain, release, retainCount, and autorelease.<br> 2.Forget about using NSAllocateObject and NSDeallocateObject.<br> 3.Follow the naming rule for methods related to object creation.<br>     create ownership:alloc/new/copy/mutableCopy/- (instanceType)initWithXXX</p>
<p> 4.Forget about calling dealloc explicitly.<br>     dealloc is a suitable place to remove the object from delegate or observers.</p>
<p> 5.Use @autoreleasepool instead of NSAutoreleasePool.<br> 6.Forget about using Zone (NSZone)<br>     现在CPU的负载能力不需要NSZone这种会带来碎片化的机制<br> 7.Object type variables can’t be members of struct or union in C language.<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">8.</span>‘id’ <span class="keyword">and</span> ‘void*’ have <span class="keyword">to</span> be cast explicitly.  </div><div class="line"><span class="keyword">With</span> ARC,<span class="keyword">To</span> cast between ‘id’ <span class="keyword">or</span> <span class="built_in">object</span> types <span class="keyword">and</span> <span class="comment">'void*',you can use __bridge</span></div></pre></td></tr></table></figure></p>
<pre><code>//dangerous: should be careful,since you don&apos;t know whether p have ownership or not.
id obj = [[NSObject alloc] init];   
void *p = (__bridge void *)obj;
id o = (__bridge id)p;

//__bridge dangling pointer example
    void *p = nil;
{
    id obj = [NSObject new];
    p = (__bridge void *)obj;
}
NSLog(@&quot;%@&quot;,(__bridge id)p);//错误,野指针
</code></pre><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">`__bridge_retained` 和 `__bridge_transfer` 都是用来解决`void *`的ownership的</div></pre></td></tr></table></figure>
<pre><code>//__bridge_retained:__bridge_retained cast works as if the assigned variable has ownership of the object
//example 1
id obj = [[NSObject alloc] init];
void *p = (__bridge_retained void *)obj;//pointer p也有ownership

//example 2
void *p = 0;
{
    id obj = [[NSObject alloc] init];
    p = (__bridge_retained void *)obj;
}
NSLog(@&quot;class=%@&quot;, [(__bridge id)p class]);//after leave the scrope variable, p still have ownership
</code></pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">	<span class="comment">//__bridge_transfer:__bridge_transfer cast will release the object just after the assignment is done.</span></div><div class="line">	<span class="comment">//example 1</span></div><div class="line">	<span class="keyword">id</span> obj = (__bridge_transfer <span class="keyword">id</span>)p;</div><div class="line">	<span class="comment">//example 2</span></div><div class="line">	<span class="keyword">void</span> *p = (__bridge_retained <span class="keyword">void</span> *)[[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">	<span class="built_in">NSLog</span>(<span class="string">@"class=%@"</span>, [(__bridge <span class="keyword">id</span>)p <span class="keyword">class</span>]);</div><div class="line">	(<span class="keyword">void</span>)(__bridge_transfer <span class="keyword">id</span>)p;</div></pre></td></tr></table></figure>
<h5 id="Core-Foundation"><a href="#Core-Foundation" class="headerlink" title="Core Foundation"></a>Core Foundation</h5><blockquote>
<p>iOS的系统架构分为四个层次：核心操作系统层（Core OS layer）、核心服务层（Core Services layer）、媒体层（Media layer）和可触摸层（Cocoa Touch layer）。Core Foundation框架 (CoreFoundation.framework) 是一组C语言接口，它们为iOS应用程序提供基本数据管理和服务功能。位于第二层核心服务层<br>cocoa Foundation框架位于第四层。<br><a href="https://developer.apple.com/library/content/documentation/CoreFoundation/Conceptual/CFDesignConcepts/CFDesignConcepts.html#//apple_ref/doc/uid/10000122i" target="_blank" rel="external">CoreFoundation</a></p>
</blockquote>
<p>OBJECTIVE-C OBJECT AND CORE FOUNDATION OBJECT<br>1.Core Foundation,mainly written in C;has reference counting<br>2.<a href="https://developer.apple.com/library/content/documentation/CoreFoundation/Conceptual/CFDesignConcepts/Articles/tollFreeBridgedTypes.html#//apple_ref/doc/uid/TP40010677-SW1" target="_blank" rel="external">Toll-Free Bridged Types</a>:There are a number of data types in the Core Foundation framework and the Foundation framework that can be used interchangeably. Data types that can be used interchangeably are also referred to as toll-free bridged data types</p>
<p>CFBridgingRetain function</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFTypeRef</span> <span class="built_in">CFBridgingRetain</span>(<span class="keyword">id</span> X) &#123;	<span class="keyword">return</span> (__bridge_retained <span class="built_in">CFTypeRef</span>)X;&#125;</div></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFMutableArrayRef</span> cfObject = <span class="literal">NULL</span>;</div><div class="line">&#123;	<span class="keyword">id</span> obj = [[<span class="built_in">NSMutableArray</span> alloc] init];	cfObject = <span class="built_in">CFBridgingRetain</span>(obj);<span class="comment">//warning...</span></div><div class="line">	<span class="comment">//cfObject =  (__bridge_retained CFMutableArrayRef)obj;//no warning</span></div><div class="line">	<span class="built_in">CFShow</span>(cfObject);	printf(<span class="string">"retain count = %d\n"</span>, <span class="built_in">CFGetRetainCount</span>(cfObject));&#125;	printf(<span class="string">"retain count after the scope = %d\n"</span>, 	<span class="built_in">CFGetRetainCount</span>(cfObject)); <span class="built_in">CFRelease</span>(cfObject);</div></pre></td></tr></table></figure>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CFMutableArrayRef cfObject = CFArrayCreateMutable(<span class="name">kCFAllocatorDefault</span>, <span class="number">0</span>, NULL)<span class="comment">;</span>printf(<span class="string">"retain count = %d\n"</span>, CFGetRetainCount(<span class="name">cfObject</span>))<span class="comment">;</span>id obj = CFBridgingRelease(<span class="name">cfObject</span>)<span class="comment">;</span>printf(<span class="string">"retain count after the cast = %d\n"</span>, 	CFGetRetainCount(<span class="name">cfObject</span>))<span class="comment">; NSLog(@"class=%@", obj);</span></div></pre></td></tr></table></figure>
<h4 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h4><table>
<thead>
<tr>
<th>Property modifier</th>
<th>Ownership qualifier</th>
</tr>
</thead>
<tbody>
<tr>
<td>assign</td>
<td>__unsafe _unretained</td>
</tr>
<tr>
<td>copy</td>
<td>__strong (note: new copied object is assigned.)</td>
</tr>
<tr>
<td>retain</td>
<td>__strong</td>
</tr>
<tr>
<td>strong</td>
<td>__strong</td>
</tr>
<tr>
<td>unsafe_unretained</td>
<td>__unsafe _unretained</td>
</tr>
<tr>
<td>weak</td>
<td>__weak  </td>
</tr>
</tbody>
</table>
<hr>
<h3 id="Chapter-3-ARC-implementation"><a href="#Chapter-3-ARC-implementation" class="headerlink" title="Chapter 3 ARC implementation"></a>Chapter 3 ARC implementation</h3><hr>
<h4 id="strong"><a href="#strong" class="headerlink" title="__strong"></a>__strong</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;	<span class="keyword">id</span> __<span class="keyword">strong</span> obj = [[<span class="built_in">NSObject</span> alloc] init];&#125;</div><div class="line"></div><div class="line"><span class="comment">/* pseudo code by the compiler */</span><span class="keyword">id</span> obj = objc_msgSend(<span class="built_in">NSObject</span>, <span class="keyword">@selector</span>(alloc));</div><div class="line">objc_msgSend(obj, <span class="keyword">@selector</span>(init));</div><div class="line">objc_release(obj);</div></pre></td></tr></table></figure>
<p>an object is not obtained by the alloc/new/copy/mutableCopy</p>
<p>objc_retainAutoreleasedReturnValue:  </p>
<ol>
<li><strong><code>objc_retainAutoreleasedReturnValue</code></strong> function is for performance optimization. It is inserted because the NSMutableArray class method array is not in the alloc/new/copy/mutableCopy method group. <code>The compiler</code> inserts this function every time just after the invocation of a method if the method is not in the group. As the name suggests, it <code>retains</code> an object returned from a method or function after <code>the object is added in autorelease pool</code>.  </li>
<li><strong><code>objc_retainAutoreleasedReturnValue</code></strong> function expects that an <strong><code>objc_autoreleaseReturnValue</code></strong> function has been called inside the method. Any methods, that are not in the alloc/new/copy/mutableCopy group, have to call <strong><code>objc_autoreleaseReturnValue</code></strong></li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;	<span class="keyword">id</span> __<span class="keyword">strong</span> obj = [<span class="built_in">NSMutableArray</span> array];&#125;</div><div class="line"></div><div class="line"><span class="comment">/* pseudo code by the compiler */</span><span class="keyword">id</span> obj = objc_msgSend(<span class="built_in">NSMutableArray</span>, <span class="keyword">@selector</span>(array));</div><div class="line">objc_retainAutoreleasedReturnValue(obj);</div><div class="line">objc_release(obj);</div></pre></td></tr></table></figure>
<p>objc_autoreleaseReturnValue</p>
<ol>
<li><code>objc_autoreleaseReturnValue</code> adds an object to autorelease pool and returns it</li>
<li><p><code>objc_autoreleaseReturnValue</code> checks <code>the caller’s executable code</code> and if the code calls <code>objc_retainAutoreleasedReturnValue</code> just after calling this method: <strong>it just returns the object to the caller,So, performance will be improved.</strong></p>
<blockquote>
<p>返回值身上调用objc_autoreleaseReturnValue方法时，runtime将这个返回值object储存在TLS中，然后直接返回这个object（不调用autorelease）；同时，在外部接收这个返回值的objc_retainAutoreleasedReturnValue里，发现TLS中正好存了这个对象，那么直接返回这个object（不调用retain）。于是乎，调用方和被调方利用TLS做中转，很有默契的免去了对返回值的内存管理。<mark>即是说如果确认方法返回值一定会被其他引用持有的话,那么就不需要放进缓存池</mark></p>
</blockquote>
</li>
</ol>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (id)<span class="built_in"> array </span>&#123;<span class="built_in">	return </span>[[NSMutableArray alloc] init];</div><div class="line">&#125;This source code is converted as follows. It calls objc_autoreleaseReturnValue function at the last./* pseudo code by the compiler */ + (id)<span class="built_in"> array</span>&#123;	id obj = objc_msgSend(NSMutableArray, @selector(alloc));</div><div class="line">	objc_msgSend(obj, @selector(init));<span class="built_in">	return </span>objc_autoreleaseReturnValue(obj);&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170713155559.png" alt="SamuelChan/20170713155559.png"></p>
<h4 id="weak"><a href="#weak" class="headerlink" title="__weak"></a>__weak</h4><ul>
<li>Nil is assigned to any variables qualified with __weak when referencing object is discarded.</li>
<li><del> When an object is accessed through a __weak qualified variable, the object is added to the autorelease pool:</del> wrong guide</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* example */</span></div><div class="line">&#123;	<span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = obj;&#125;<span class="comment">/* pseudo code by the compiler */</span></div><div class="line"><span class="keyword">id</span> obj1;objc_initWeak(&amp;obj1, obj); <span class="comment">//call obj1 = 0; objc_storeWeak(&amp;obj1, obj);</span></div><div class="line">objc_destroyWeak(&amp;obj1);   <span class="comment">//call objc_storeWeak(&amp;obj1, 0);</span></div></pre></td></tr></table></figure>
<blockquote>
<p><code>Hash table</code> : 我们知道，数组的最大特点就是：寻址容易，插入和删除困难；而链表正好相反，寻址困难，而插入和删除操作容易。那么如果能够结合两者的优点，做出一种寻址、插入和删除操作同样快速容易的数据结构，那该有多好。这就是哈希表创建的基本思想，而实际上哈希表也实现了这样的一个“夙愿”，哈希表就是这样一个集查找、插入和删除操作于一身的数据结构。  </p>
</blockquote>
<p><code>objc_storeWeak</code>:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * This function stores a new value into a __weak variable. It would</div><div class="line"> * be used anywhere a __weak variable is the target of an assignment.</div><div class="line"> *</div><div class="line"> * @param location The address of the weak pointer itself</div><div class="line"> * @param newObj The new object this weak ptr should now point to</div><div class="line"> *</div><div class="line"> * @return \e newObj</div><div class="line"> */</div><div class="line">id objc_storeWeak(id *location, id newObj)</div><div class="line"></div><div class="line">//when obj = 0,the entry remove from hash table</div><div class="line">objc_storeWeak(&amp;obj1, obj);</div></pre></td></tr></table></figure>
<p><code>When an Object Is Discarded</code>  </p>
<ol>
<li>objc_release.</li>
<li>dealloc is called because retain count becomes zero.</li>
<li>_objc_rootDealloc.</li>
<li>object_dispose.</li>
<li>objc_destructInstance.</li>
<li>objc_clear_deallocating:<ol>
<li>From the weak table, get an entry of which the key is the object to be discarded.</li>
<li>Set nil to all the __weak ownership qualified variables in the entry.</li>
<li>Remove the entry from the table.</li>
<li>For the object to be disposed of, remove its <code>key</code> from the <strong><code>reference table</code></strong>.</li>
</ol>
</li>
</ol>
<p><code>Assigning a Newly Created Object</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;	<span class="keyword">id</span> __<span class="keyword">weak</span> obj = [[<span class="built_in">NSObject</span> alloc] init];&#125;</div><div class="line"></div><div class="line"><span class="comment">/* pseudo code by the compiler */</span><span class="keyword">id</span> obj;<span class="keyword">id</span> tmp = objc_msgSend(<span class="built_in">NSObject</span>, <span class="keyword">@selector</span>(alloc));</div><div class="line">objc_msgSend(tmp, <span class="keyword">@selector</span>(init));</div><div class="line">objc_initWeak(&amp;obj, tmp);objc_release(tmp);objc_destroyWeak(&amp;object);</div></pre></td></tr></table></figure>
<p><strong><del>Adding to autorelease pool Automatically</del></strong><br>验证汇编代码: Xcode → Debug → Debug workflow → Always show Disassembly.<br>输入下面的例子,会看到编译器插入的是release不是autorelease</p>
<p>In conclusion, this design of <strong>weak ensure that during the usage of weak pointer, its state is consistent. The <code>new</code> implmenetation of </strong>weak of <code>Apple LLVM version 8.0.0 (clang-800.0.42.1)</code> do not postpond the release to autoreleasepool, but use <code>objc_release</code> <strong>directly</strong>.</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123;	id __weak obj1 = obj<span class="comment">;</span></div><div class="line">	NSLog(@<span class="string">"%@"</span>, obj1)<span class="comment">;</span>&#125;</div><div class="line"><span class="comment">/* iOS5及之前编译器做法 */</span>id obj1<span class="comment">;</span>objc_initWeak(&amp;obj1, obj)<span class="comment">;</span>id tmp = objc_loadWeakRetained(&amp;obj1)<span class="comment">;</span></div><div class="line">objc_autorelease(tmp)<span class="comment">;//错误!!!mistake</span>NSLog(@<span class="string">"%@"</span>, tmp)<span class="comment">;</span></div><div class="line">objc_destroyWeak(&amp;obj1)<span class="comment">;</span></div><div class="line"></div><div class="line"><span class="comment">/* 现在的编译器做法*/</span></div><div class="line">id obj = objc_msgSend(NSObject, <span class="string">"new"</span>)<span class="comment">;</span></div><div class="line">id obj1<span class="comment">;</span></div><div class="line">objc_initWeak(&amp;obj1, obj)<span class="comment">;</span></div><div class="line">id tmp = objc_loadWeakRetained(obj1)<span class="comment">;//objc_loadWeakRetained would increment the reference count to ensure that tmp is alive in the NSLog statement.</span></div><div class="line">NSLog(@<span class="string">"%@"</span>, obj1)<span class="comment">;</span></div><div class="line">objc_release(tmp)<span class="comment">;</span></div><div class="line">objc_destroyWeak(&amp;obj1)<span class="comment">;</span></div><div class="line">objc_storeStrong(&amp;obj, <span class="number">0</span>)<span class="comment">;//release</span></div></pre></td></tr></table></figure>
<p><a href="lists.apple.com/archives/objc-language/2012/Aug/msg00027.htm‌​l">苹果list</a><br><a href="https://stackoverflow.com/questions/40993809/why-weak-object-will-be-added-to-autorelease-pool/41008619#41008619" target="_blank" rel="external">参考资料1</a><br><a href="https://stackoverflow.com/questions/34083137/objective-c-weak-object-is-registered-in-autoreleasepool-automatically?rq=1" target="_blank" rel="external">参考资料2</a></p>
<h4 id="autoreleasing"><a href="#autoreleasing" class="headerlink" title="__autoreleasing"></a>__autoreleasing</h4><p>```<br>@autoreleasepool {<br>    id __autoreleasing obj = [[NSObject alloc] init];<br>}</p>
<p>/<em> pseudo code by the compiler </em>/<br>id pool = objc_autoreleasePoolPush();<br>id obj = objc_msgSend(NSObject, @selector(alloc));<br>objc_msgSend(obj, @selector(init));<br>objc_autorelease(obj);                     //放进自动释放池<br>objc_autoreleasePoolPop(pool);</p>
<p>@autoreleasepool {<br>    id __autoreleasing obj = [NSMutableArray array];<br>}</p>
<p>/<em> pseudo code by the compiler </em>/<br>id pool = objc_autoreleasePoolPush();<br>id obj = objc_msgSend(NSMutableArray, @selector(array));<br>objc_retainAutoreleasedReturnValue(obj);<br>objc_autorelease(obj);<br>objc_autoreleasePoolPop(pool);<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">#### Reference Count</span></div><div class="line"><span class="string">`uintptr_t</span> <span class="string">_objc_rootRetainCount(id</span> <span class="string">obj)`:don't</span> <span class="string">return</span> <span class="string">reliable</span> <span class="string">value</span> <span class="string">all</span> <span class="string">the</span> <span class="string">time</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">---</span></div><div class="line"><span class="comment">### NSObject开源之后关于release,retain,dealloc内存管理的实现</span></div><div class="line"><span class="meta">---</span></div><div class="line"><span class="string">&gt; 1. 本书本之前讨论的内存管理是基于GNUStep或者是CFFoundation里面的内存管理部分.现在NSObject已经开源了</span></div><div class="line">&gt; 2. [objc4-709](https://opensource.apple.com/tarballs/objc4/)</div><div class="line"></div><div class="line">#### 引用计数的储存</div><div class="line">有些对象如果支持使用`TaggedPointer`，苹果会直接将其指针值作为引用计数返回；否则 Runtime 会使用一张`散列表`来管理引用计数。</div><div class="line"></div><div class="line">#### 一些概念</div><div class="line">#####1.TaggedPointer: 判断当前对象是否在使用 TaggedPointer 是看标志位是否为 1;id的isTaggedPointer()方法经常会在操作引用计数时用到，因为这决定了存储引用计数的策略。</div></pre></td></tr></table></figure></p>
<p>#if SUPPORT_MSB_TAGGED_POINTERS</p>
<h1 id="define-TAG-MASK-1ULL-lt-lt-63"><a href="#define-TAG-MASK-1ULL-lt-lt-63" class="headerlink" title="define TAG_MASK (1ULL&lt;&lt;63)"></a>define TAG_MASK (1ULL&lt;&lt;63)</h1><p>#else</p>
<h1 id="define-TAG-MASK-1"><a href="#define-TAG-MASK-1" class="headerlink" title="define TAG_MASK 1"></a>define TAG_MASK 1</h1><p>inline bool<br>objc_object::isTaggedPointer()<br>{</p>
<p>#if SUPPORT_TAGGED_POINTERS<br>    return ((uintptr_t)this &amp; TAG_MASK);</p>
<p>#else<br>    return false;</p>
<p>#endif<br>}</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#####<span class="number">2.</span>散列表</div></pre></td></tr></table></figure>
<p>struct SideTable {<br>    // 保证原子操作的自旋锁<br>    spinlock_t slock;<br>    // 引用计数的 hash 表<br>    RefcountMap refcnts;<br>    // weak 引用全局 hash 表<br>    weak_table_t weak_table;<br>};</p>
<p>SideTable 结构体重定了几个非常重要的变量。<br>// The order of these bits is important.</p>
<p>#define SIDE_TABLE_WEAKLY_REFERENCED (1UL&lt;&lt;0)    </p>
<p>#define SIDE_TABLE_DEALLOCATING      (1UL&lt;&lt;1)  // MSB-ward of weak bit</p>
<p>#define SIDE_TABLE_RC_ONE            (1UL&lt;&lt;2)  // MSB-ward of deallocating bit</p>
<p>#define SIDE_TABLE_RC_PINNED         (1UL&lt;&lt;(WORD_BITS-1))//最高位字节为0</p>
<p>#define SIDE_TABLE_RC_SHIFT 2</p>
<p>#define SIDE_TABLE_FLAG_MASK (SIDE_TABLE_RC_ONE-1)<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">![<span class="string">SamuelChan/20170717173215.png</span>](<span class="link">http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170717173215.png</span>)</div><div class="line"></div><div class="line"><span class="section">#####3.retainCount</span></div></pre></td></tr></table></figure></p>
<ul>
<li>(NSUInteger)retainCount {<br>  return ((id)self)-&gt;rootRetainCount();<br>}</li>
</ul>
<p>inline uintptr_t<br>objc_object::rootRetainCount()<br>{<br>    if (isTaggedPointer()) return (uintptr_t)this;<br>    return sidetable_retainCount();<br>}</p>
<p>uintptr_t<br>objc_object::sidetable_retainCount()<br>{<br>    SideTable&amp; table = SideTables()[this];<br>    size_t refcnt_result = 1;</p>
<pre><code>table.lock();
RefcountMap::iterator it = table.refcnts.find(this);
if (it != table.refcnts.end()) {
    // this is valid for SIDE_TABLE_RC_PINNED too
    refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;//右移两位
}
table.unlock();
return refcnt_result;
</code></pre><p>}<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#####<span class="number">4.</span>retain</div></pre></td></tr></table></figure></p>
<ul>
<li>(id)retain {<br>  return ((id)self)-&gt;rootRetain();<br>}</li>
</ul>
<p>// Base retain implementation, ignoring overrides.<br>// This does not check isa.fast_rr; if there is an RR override then<br>// it was already called and it chose to call [super retain].<br>inline id<br>objc_object::rootRetain()<br>{<br>    if (isTaggedPointer()) return (id)this;<br>    return sidetable_retain();<br>}</p>
<p>id<br>objc_object::sidetable_retain()<br>{</p>
<p>#if SUPPORT_NONPOINTER_ISA<br>    assert(!isa.nonpointer);</p>
<p>#endif<br>    SideTable&amp; table = SideTables()[this];</p>
<pre><code>table.lock();
size_t&amp; refcntStorage = table.refcnts[this];
if (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) {
    //相当于+(1 &lt;&lt; 2)
    refcntStorage += SIDE_TABLE_RC_ONE;
}
table.unlock();
return (id)this;
</code></pre><p>}</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### <span class="number">5.</span> release</div></pre></td></tr></table></figure>
<ul>
<li>(oneway void)release {<br>  ((id)self)-&gt;rootRelease();<br>}</li>
</ul>
<p>inline bool<br>objc_object::rootRelease()<br>{<br>    if (isTaggedPointer()) return false;<br>    return sidetable_release(true);<br>}</p>
<p>// rdar://20206767<br>// return uintptr_t instead of bool so that the various raw-isa<br>// -release paths all return zero in eax<br>uintptr_t<br>objc_object::sidetable_release(bool performDealloc)<br>{</p>
<p>#if SUPPORT_NONPOINTER_ISA<br>    assert(!isa.nonpointer);</p>
<p>#endif<br>    SideTable&amp; table = SideTables()[this];<br>    bool do_dealloc = false;<br>    table.lock();<br>    RefcountMap::iterator it = table.refcnts.find(this);<br>    if (it == table.refcnts.end()) {<br>        do_dealloc = true;<br>        table.refcnts[this] = SIDE_TABLE_DEALLOCATING;<br>    } else if (it-&gt;second &lt; SIDE_TABLE_DEALLOCATING) {<br>        // 判断引用计数是否为0,如果小于SIDE_TABLE_DEALLOCATING,只有00000001或者00000000,两种情况下,引用计数都为0,所以需要将do_dealloc置为0<br>        // SIDE_TABLE_WEAKLY_REFERENCED may be set. Don’t change it.<br>        do_dealloc = true;<br>        it-&gt;second |= SIDE_TABLE_DEALLOCATING;<br>    } else if (! (it-&gt;second &amp; SIDE_TABLE_RC_PINNED)) {<br>         // 如果符合这个条件,即:引用计数没有溢出(最高位为0),do_dealloc为0,weak_reference为0)<br>        it-&gt;second -= SIDE_TABLE_RC_ONE;<br>    }<br>    table.unlock();<br>    if (do_dealloc  &amp;&amp;  performDealloc) {<br>        ((void(<em>)(objc_object </em>, SEL))objc_msgSend)(this, SEL_dealloc);<br>    }<br>    return do_dealloc;<br>}</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#####<span class="number">5.</span> alloc</div><div class="line">```+alloc</div><div class="line">+allocWithZone:</div><div class="line">class_createInstance</div><div class="line">calloc</div></pre></td></tr></table></figure>
<p>#####6.dealloc</p>
<ol>
<li>objc_release.</li>
<li>dealloc is called because retain count becomes zero.</li>
<li>_objc_rootDealloc.</li>
<li>object_dispose.</li>
<li>objc_destructInstance</li>
<li>objc_clear_deallocating:<ol>
<li>From the weak table, get an entry of which the key is the object to be discarded.</li>
<li>Set nil to all the __weak ownership qualified variables in the entry.</li>
<li>Remove the entry from the table.</li>
<li>For the object to be disposed of, remove its <code>key</code> from the <strong><code>reference table</code></strong></li>
</ol>
</li>
</ol>
<p>#####7.autorelease<br>参考资料:<br><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="external">黑幕背后的Autorelease</a></p>
<ul>
<li>Autorelease对象什么时候释放？<br>在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的runloop迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop</li>
<li>AutoreleasePoolPage:是一个C++实现的类,<br><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170717194057.png" alt="SamuelChan/20170717194057.png"><ul>
<li>AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage以<a href="http://www.cnblogs.com/skywang12345/p/3561803.html#a31" target="_blank" rel="external">双向链表</a>的形式组合而成（分别对应结构中的parent指针和child指针）</li>
<li>AutoreleasePool是按线程一一对应的（结构中的thread指针指向当前线程）</li>
<li>AutoreleasePoolPage每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地址</li>
<li>上面的id *next指针作为游标指向栈顶最新add进来的autorelease对象的下一个位置</li>
<li>一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入</li>
</ul>
</li>
<li>AutoreleasePoolPage快要满的时候:也就是next指针马上指向栈顶，这时就要执行上面说的操作，建立下一页page对象，与这一页链表连接完成后，新page的next指针被初始化在栈底（begin的位置），然后继续向栈顶添加新对象。</li>
</ul>
<p><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170717194341.png" alt="SamuelChan/20170717194341.png"></p>
<ul>
<li>释放时刻:根据哨兵位置进行pop释放池,每当进行一次objc_autoreleasePoolPush调用时，runtime向当前的AutoreleasePoolPage中add进一个哨兵对象，值为0（也就是个nil）<br><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170717194612.png" alt="SamuelChan/20170717194612.png"></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> *<span class="keyword">context</span> = objc_autoreleasePoolPush();</div><div class="line"><span class="comment">// &#123;&#125;中的代码</span></div><div class="line">objc_autoreleasePoolPop(<span class="keyword">context</span>);</div></pre></td></tr></table></figure>
<ul>
<li>使用容器的block版本的枚举器时，内部会自动添加一个AutoreleasePool,普通for/for in中没有  </li>
</ul>
<figure class="highlight hy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> [array enumerateObjectsUsingBlock:^(<span class="name"><span class="builtin-name">id</span></span> obj, NSUInteger idx, BOOL *stop) &#123;</div><div class="line">    // 这里被一个局部@autoreleasepool包围着</div><div class="line">&#125;]<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>参考资料:<br>1.<a href="http://yulingtianxia.com/blog/2015/12/06/The-Principle-of-Refenrence-Counting/" target="_blank" rel="external">Objective-C 引用计数原理</a>,部分地方最新的obj4版本已经改了<br>2.<a href="http://zhoulingyu.com/2017/02/15/Advanced-iOS-Study-objc-Memory-2/" target="_blank" rel="external">iOS进阶——iOS（Objective-C）内存管理·二
</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Problems:  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个非alloc/new/copy/muteCopy返回对象的方法应该由谁管理内存?  &lt;/li&gt;
&lt;li&gt;AutoReleasePool也需要进行内存管理吗?如果要,谁来管理?&lt;/li&gt;
&lt;/ol
    
    </summary>
    
      <category term="Objective-C" scheme="http://yoursite.com/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>禅与Objective-C编程艺术读书笔记</title>
    <link href="http://yoursite.com/2017/06/30/%E7%A6%85%E4%B8%8EObjective-C%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/"/>
    <id>http://yoursite.com/2017/06/30/禅与Objective-C编程艺术/</id>
    <published>2017-06-30T03:06:52.000Z</published>
    <updated>2017-07-19T12:49:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="禅与Objective-C编程艺术读书笔记"><a href="#禅与Objective-C编程艺术读书笔记" class="headerlink" title="禅与Objective-C编程艺术读书笔记"></a>禅与Objective-C编程艺术读书笔记</h3><h4 id="1-条件语句"><a href="#1-条件语句" class="headerlink" title="1.条件语句"></a>1.条件语句</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> <span class="keyword">if</span> (!error) &#123;</div><div class="line">	<span class="keyword">return</span> success;&#125;</div><div class="line"></div><div class="line"><span class="number">2.</span> 不使用尤达表达式</div><div class="line"><span class="keyword">if</span> ([myValue isEqual:@<span class="number">42</span>]) &#123; ...</div><div class="line"></div><div class="line"><span class="number">3.</span> <span class="literal">nil</span>跟<span class="built_in">BOOL</span>检查: <span class="literal">nil</span>解释为<span class="literal">NO</span> <span class="literal">YES</span>解释为<span class="number">1</span></div><div class="line"><span class="keyword">if</span> (someObject) &#123; ...</div><div class="line"><span class="keyword">if</span> (![someObject boolValue]) &#123; ...</div><div class="line"><span class="keyword">if</span> (!someObject) &#123; ...</div><div class="line">Not Preferred:</div><div class="line"><span class="keyword">if</span> (someObject == <span class="literal">YES</span>) &#123; ... <span class="comment">// Wrong</span></div><div class="line"><span class="keyword">if</span> (myRawValue == <span class="literal">YES</span>) &#123; ... <span class="comment">// Never do this.</span></div><div class="line"><span class="keyword">if</span> ([someObject boolValue] == <span class="literal">NO</span>) &#123; <span class="comment">//Wrong</span></div><div class="line"></div><div class="line"><span class="number">4.</span> Golden Path: 不要嵌套<span class="keyword">if</span>,减少复杂度</div><div class="line">- (<span class="keyword">void</span>)someMethod &#123;</div><div class="line">  <span class="keyword">if</span> (![someOther boolValue]) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//Do something important</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="number">5.</span>复杂的条件表达式:如果<span class="keyword">if</span>的条件判断很复杂,建议先赋值给变量名清晰的<span class="built_in">BOOL</span>变量</div><div class="line"><span class="built_in">BOOL</span> nameContainsSwift = [sessionName containsString:<span class="string">@"Swift"</span>];  </div><div class="line"><span class="built_in">BOOL</span> isCurrentYear = [sessionDateCompontents year] == <span class="number">2014</span>;</div><div class="line"><span class="built_in">BOOL</span> isSwiftSession = nameContainsSwift &amp;&amp; isCurrentYear;<span class="keyword">if</span> (isSwiftSession) &#123;<span class="comment">// Do something very cool</span>&#125;</div><div class="line"></div><div class="line"><span class="number">6.</span> 三元运算符:优先级从右到左</div><div class="line">result = object ? : [<span class="keyword">self</span> createObject];</div><div class="line"></div><div class="line"><span class="number">7.</span> <span class="keyword">case</span>: 单行括号不强制,执行直到<span class="keyword">break</span></div><div class="line"><span class="number">8.</span> 位移枚举</div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">UIViewAutoresizing</span>) &#123;    二进制值    十进制</div><div class="line">    <span class="built_in">UIViewAutoresizingNone</span>                 = <span class="number">0</span>,         <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0</span></div><div class="line">    <span class="built_in">UIViewAutoresizingFlexibleLeftMargin</span>   = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,    <span class="number">0000</span> <span class="number">0001</span>  <span class="number">1</span></div><div class="line">    <span class="built_in">UIViewAutoresizingFlexibleWidth</span>        = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,    <span class="number">0000</span> <span class="number">0010</span>  <span class="number">2</span></div><div class="line">    <span class="built_in">UIViewAutoresizingFlexibleRightMargin</span>  = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,    <span class="number">0000</span> <span class="number">0100</span>  <span class="number">4</span></div><div class="line">    <span class="built_in">UIViewAutoresizingFlexibleTopMargin</span>    = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,    <span class="number">0000</span> <span class="number">1000</span>  <span class="number">8</span></div><div class="line">    <span class="built_in">UIViewAutoresizingFlexibleHeight</span>       = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,    <span class="number">0001</span> <span class="number">0000</span>  <span class="number">16</span></div><div class="line">    <span class="built_in">UIViewAutoresizingFlexibleBottomMargin</span> = <span class="number">1</span> &lt;&lt; <span class="number">5</span>     <span class="number">0010</span> <span class="number">0000</span>  <span class="number">32</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//模拟实现</span></div><div class="line">-(<span class="keyword">void</span>)todo:(<span class="built_in">UIViewAutoresizing</span>)type&#123;</div><div class="line">    <span class="keyword">if</span> (type==<span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"UIViewAutoresizingNone"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (type &amp; <span class="built_in">UIViewAutoresizingFlexibleLeftMargin</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"UIViewAutoresizingFlexibleLeftMargin"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (type &amp; <span class="built_in">UIViewAutoresizingFlexibleWidth</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"UIViewAutoresizingFlexibleWidth"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (type &amp; <span class="built_in">UIViewAutoresizingFlexibleRightMargin</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"UIViewAutoresizingFlexibleRightMargin"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (type &amp; <span class="built_in">UIViewAutoresizingFlexibleTopMargin</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"UIViewAutoresizingFlexibleTopMargin"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (type &amp; <span class="built_in">UIViewAutoresizingFlexibleHeight</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"UIViewAutoresizingFlexibleHeight"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (type &amp; <span class="built_in">UIViewAutoresizingFlexibleBottomMargin</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"UIViewAutoresizingFlexibleBottomMargin"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line"></div><div class="line">    [<span class="keyword">self</span> todo:<span class="built_in">UIViewAutoresizingFlexibleLeftMargin</span>|<span class="built_in">UIViewAutoresizingFlexibleRightMargin</span>|<span class="built_in">UIViewAutoresizingFlexibleHeight</span>];</div><div class="line">&#125;</div><div class="line">结果输出</div><div class="line"><span class="built_in">UIViewAutoresizingFlexibleLeftMargin</span></div><div class="line"><span class="built_in">UIViewAutoresizingFlexibleRightMargin</span></div><div class="line"><span class="built_in">UIViewAutoresizingFlexibleHeight</span></div></pre></td></tr></table></figure>
<h4 id="2-命名规范"><a href="#2-命名规范" class="headerlink" title="2.命名规范"></a>2.命名规范</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span>变量: 驼峰命名,类名开头</div><div class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> ZOCSignInViewControllerFadeOutAnimationDuration = <span class="number">0.4</span>;</div><div class="line"></div><div class="line">	<span class="comment">/*static NSString const * kUserName = static NSString const (* kUserName )</span></div><div class="line">     kUserName为指针, *kUserName是指针指向的地址的内容</div><div class="line">     static NSString const * kUserName代表常量指针:指针必须指向任意一个常量</div><div class="line">     */</div><div class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> <span class="keyword">const</span> *kUserName = <span class="string">@"kUserName"</span>;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"kUserName = %p,*kUserName = %p"</span>,&amp;kUserName,&amp;(*kUserName));</div><div class="line">    kUserName = <span class="string">@"OtherName"</span>;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"kUserName = %p,*kUserName = %p"</span>,&amp;kUserName,&amp;(*kUserName));</div><div class="line"></div><div class="line">    <span class="comment">/*static NSString *const kUserName = static NSString  * const (kUserName)</span></div><div class="line">     kUserName为指针常量</div><div class="line">     */</div><div class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> name = <span class="string">@"name"</span>;</div><div class="line">	<span class="comment">//name = @"kfkfkfk";//错误</span></div><div class="line"></div><div class="line"><span class="number">2.</span>方法</div><div class="line">  类(-/+)间应该以空格间隔,方法段之间也应该用空格隔开</div><div class="line">  尽可能少用and作为方法段名</div><div class="line">  - (<span class="keyword">instancetype</span>)initWith:(<span class="keyword">int</span>)width and:(<span class="keyword">int</span>)height; <span class="comment">// Never do this.</span></div><div class="line">  推荐一下写法:</div><div class="line">  - (<span class="keyword">void</span>)setExampleText:(<span class="built_in">NSString</span> *)text image:(<span class="built_in">UIImage</span> *)image;  - (<span class="keyword">void</span>)sendAction:(SEL)aSelector to:(<span class="keyword">id</span>)anObject forAllCells:(<span class="built_in">BOOL</span>)flag; - (<span class="keyword">id</span>)viewWithTag:(<span class="built_in">NSInteger</span>)tag;  - (<span class="keyword">instancetype</span>)initWithWidth:(<span class="built_in">CGFloat</span>)width height:(<span class="built_in">CGFloat</span>)height;</div></pre></td></tr></table></figure>
<h4 id="3-类"><a href="#3-类" class="headerlink" title="3.类"></a>3.类</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span>类名: 头三个字母最好是大写,避免与头两个字母是大写的苹果官方类冲突</div><div class="line"><span class="number">2.</span>initializer</div><div class="line">	alloc 负责创建对象，这个过程包括分配足够的内存来保存对象，写入 isa 指针，初始化引用计数，以及重置所有实例变量。</div><div class="line">	init 负责初始化对象，这意味着使对象处于可用状态。这通常意味着为对象的实例变量赋予合理有用的值。</div><div class="line"><span class="number">3.</span>designated initializer secondary initializer:一个直接,多个间接.</div><div class="line"><span class="number">4.</span>单例:</div><div class="line">	+ (<span class="keyword">instancetype</span>)sharedInstance &#123;		<span class="keyword">static</span> <span class="keyword">id</span> sharedInstance = <span class="literal">nil</span>;</div><div class="line">		<span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken = <span class="number">0</span>;   </div><div class="line">		<span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;			sharedInstance = [[<span class="keyword">self</span> alloc] init];</div><div class="line">		&#125;);		<span class="keyword">return</span> sharedInstance;</div><div class="line">	&#125;</div><div class="line"><span class="number">5.</span>属性:</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">getter</span>=isEditable) <span class="built_in">BOOL</span> editable;</div><div class="line"></div><div class="line"><span class="number">6.</span>方法:</div><div class="line">参数断言:判断某个参数是否满足条件,使用<span class="built_in">NSParameterAssert</span>(),debug默认开启,release默认关闭</div><div class="line">    <span class="built_in">NSInteger</span> a = <span class="number">10</span>;</div><div class="line">    <span class="built_in">NSParameterAssert</span>(a&gt; <span class="number">1</span> &amp;&amp; a &gt; <span class="number">10</span>);</div><div class="line">自定义私有方法:不要以_开头,_是苹果保留的,不能冒重载私有方法的险</div><div class="line"></div><div class="line"><span class="number">7.</span>分类:在分类方法名加上前缀,在编写静态库时,一定要注意加上前缀,防止与使用者冲突;发生冲突的时候将会以加载顺序最后的分类方法生效</div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSDate</span> (<span class="title">ZOCTimeExtensions</span>)</span></div><div class="line">- (<span class="built_in">NSString</span> *)zoc_timeAgoShort;</div><div class="line"></div><div class="line"><span class="number">8.</span>通知:</div><div class="line"><span class="comment">// Foo.h</span><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> ZOCFooDidBecomeBarNotification</div><div class="line"><span class="comment">// Foo.m</span><span class="built_in">NSString</span> * <span class="keyword">const</span> ZOCFooDidBecomeBarNotification = <span class="string">@"ZOCFooDidBecomeBarNotification"</span>;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="number">9.</span>代理优化:从面向对象到面向协议,只需要遵守ZOCFeedParserProtocol.h的对象</div><div class="line">- (<span class="keyword">instancetype</span>)initWithFeedParser:(<span class="keyword">id</span>&lt;ZOCFeedParserProtocol&gt;)feedParser;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ZOCFeedParserDelegate</span>;</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ZOCFeedParserProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> &lt;ZOCFeedParserDelegate&gt; delegate;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURL</span> *url;</div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)start;</div><div class="line">- (<span class="keyword">void</span>)stop;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ZOCFeedParserDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"><span class="keyword">@optional</span></div><div class="line">- (<span class="keyword">void</span>)feedParserDidStart:(<span class="keyword">id</span>&lt;ZOCFeedParserProtocol&gt;)parser;</div><div class="line">- (<span class="keyword">void</span>)feedParser:(<span class="keyword">id</span>&lt;ZOCFeedParserProtocol&gt;)parser didParseFeedInfo:(<span class="keyword">id</span>)info;</div><div class="line">- (<span class="keyword">void</span>)feedParser:(<span class="keyword">id</span>&lt;ZOCFeedParserProtocol&gt;)parser didParseFeedItem:(<span class="keyword">id</span>)item;</div><div class="line">- (<span class="keyword">void</span>)feedParserDidFinish:(<span class="keyword">id</span>&lt;ZOCFeedParserProtocol&gt;)parser;</div><div class="line">- (<span class="keyword">void</span>)feedParser:(<span class="keyword">id</span>&lt;ZOCFeedParserProtocol&gt;)parser didFailWithError:(<span class="built_in">NSError</span> *)error;</div></pre></td></tr></table></figure>
<p><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170630192229.png" alt="SamuelChan/20170630192229.png"></p>
<h4 id="4-美化代码"><a href="#4-美化代码" class="headerlink" title="4.美化代码"></a>4.美化代码</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span>方法的大括号和其他(<span class="keyword">if</span>/<span class="keyword">else</span>/<span class="keyword">switch</span>/<span class="keyword">while</span>)在同一行开始,新起一行结束</div><div class="line"><span class="number">2.</span>应该总是让冒号对齐。有一些方法签名可能超过三个冒号，用冒号对齐可以让代码更具有可读性。即使有代码块存在，也应该用冒号对齐方法。</div><div class="line">	[<span class="built_in">UIView</span> animateWithDuration:<span class="number">1.0</span></div><div class="line">             	 	 animations:^&#123;</div><div class="line">                  	   <span class="comment">// something</span></div><div class="line">               	  	&#125;</div><div class="line">                 	 completion:^(<span class="built_in">BOOL</span> finished) &#123;</div><div class="line">                       <span class="comment">// something</span></div><div class="line">                 	&#125;];</div></pre></td></tr></table></figure>
<h4 id="5-代码组织"><a href="#5-代码组织" class="headerlink" title="5.代码组织"></a>5.代码组织</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.利用代码块:代码块如果在闭合的圆括号中的话,会返回最后的值</div><div class="line">NSURL *url = (&#123;	NSString *urlString = [NSString stringWithFormat:@<span class="string">"%@/%@"</span>, <span class="keyword">baseURLString, </span>endpoint]<span class="comment">;</span></div><div class="line">	[NSURL URLWithString:urlString]<span class="comment">;</span>&#125;)<span class="comment">;</span></div><div class="line"><span class="number">2</span>.<span class="comment">#pragma mark - 是一个在类内部组织代码并且帮助你分组方法实现的好办法</span></div><div class="line"></div><div class="line"><span class="number">3</span>.当你调用NSSelectorFromString的时候,编译器不确定它是否会造成内存泄露,会报警告:performSelector may <span class="built_in">cause</span> a leak <span class="keyword">because </span>its selector is unknown. 如果确定不会泄露,那么就加上下面的代码忽略警告</div><div class="line">	<span class="comment">#pragma clang diagnostic push</span>	<span class="comment">#pragma clang diagnostic ignored "-Warc-performSelector-leaks"</span>      [self performSelector:NSSelectorFromString(@<span class="string">"testtest"</span>) withObject:@<span class="string">""</span>]<span class="comment">;</span></div><div class="line">	<span class="comment">#pragma clang diagnostic pop</span></div><div class="line"></div><div class="line"><span class="number">4</span>.人为明确编译器的警告和错误:</div><div class="line"><span class="comment">#error Whoa, buddy, you need to check for zero here!</span></div><div class="line"><span class="comment">#warning Dude, don't compare floating point numbers like this!</span></div><div class="line"></div><div class="line"><span class="number">5</span>.注释相关:</div><div class="line">没有参数的方法使用<span class="string">"//"</span>进行注释</div><div class="line">只在.h中写注释</div></pre></td></tr></table></figure>
<h4 id="6-对象之间的通讯"><a href="#6-对象之间的通讯" class="headerlink" title="6.对象之间的通讯"></a>6.对象之间的通讯</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> block</div><div class="line">(<span class="number">1</span>)把提供需要的数据和错误信息整合到一个单独的block中,比分别提供成功失败的要好</div><div class="line">(<span class="built_in">NSURLSession</span>/<span class="built_in">NSURLConnection</span>)</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)downloadObjectsAtPath:(<span class="built_in">NSString</span> *)pathcompletion:(<span class="keyword">void</span>(^)(<span class="built_in">NSArray</span> *objects, <span class="built_in">NSError</span> *error))completion;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)GET:(<span class="built_in">NSString</span> *)URLString</div><div class="line">                            parameters:(<span class="keyword">nullable</span> <span class="keyword">id</span>)parameters</div><div class="line">                              progress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress))downloadProgress</div><div class="line">                               success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="keyword">id</span> _Nullable responseObject))success</div><div class="line">                               failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure;</div><div class="line"></div><div class="line">(<span class="number">2</span>)block在栈上创建</div><div class="line"></div><div class="line">(<span class="number">3</span>)可复制到堆上: block作为属性,MRC下需要使用<span class="keyword">copy</span>来将它拷贝到堆上;</div><div class="line">            ARC下只是为了一致性将block属性声明为<span class="keyword">copy</span>,编译器会自动将block拷贝到堆上</div><div class="line"></div><div class="line">(<span class="number">4</span>)block会捕获栈上的变量(指针),将其复制为自己私有的<span class="keyword">const</span>变量</div><div class="line">(<span class="number">5</span>)如果要修改block中的变量(指针),那么变量和指针必须使用__block关键字声明:__block变量的栈变量被复制到堆上,复制完成后,block将会引用的是这份已经在堆上的副本</div><div class="line">(<span class="number">6</span>)使用:</div><div class="line"> - 直接在 block 里面使用关键词 <span class="keyword">self</span>:  只能在 block 不是作为一个 property 的时候使用，否则会导致 <span class="keyword">retain</span> cycle。</div><div class="line"> - 在 block 外定义一个 __<span class="keyword">weak</span> 的 引用到 <span class="keyword">self</span>，并且在 block 里面使用这个弱引用: 当 block 被声明为一个 property 的时候使用。</div><div class="line"> - 在 block 外定义一个 __<span class="keyword">weak</span> 的 引用到 <span class="keyword">self</span>，并在在 block 内部通过这个弱引用定义一个 __<span class="keyword">strong</span> 的引用。: 和并发执行有关。当涉及异步的服务的时候，block 可以在之后被执行，并且不会发生关于 <span class="keyword">self</span> 是否存在的问题,保证在block执行期间引用的对象不被置为<span class="literal">nil</span>,但是也可能存在block执行时对象已经为空</div><div class="line"></div><div class="line"><span class="number">2.</span>DataSource和delegate   ---  委托者 vs 代理者</div><div class="line">(<span class="number">1</span>)代理方法的第一个参数必须是调用代理者:否则没有办法区分不同的委托者</div><div class="line">(<span class="number">2</span>)	<span class="keyword">@required</span> <span class="keyword">@optional</span> 默认的代理方法为<span class="keyword">@required</span></div><div class="line">	<span class="keyword">if</span> ([<span class="keyword">self</span>.delegate 	respondsToSelector:<span class="keyword">@selector</span>(signUpViewControllerDidPressSignUpButton:	)]) &#123;</div><div class="line">		[<span class="keyword">self</span>.delegate signUpViewControllerDidPressSignUpButton:<span class="keyword">self</span>];	&#125;</div><div class="line">(<span class="number">3</span>)继承代理实现:</div><div class="line">继承关系:<span class="built_in">UIViewControllerB</span> &lt; <span class="built_in">UIViewControllerA</span> &lt; <span class="built_in">UIViewController</span></div><div class="line"><span class="built_in">UIViewControllerA</span>.h遵守<span class="built_in">UITableViewDelegate</span></div><div class="line"><span class="built_in">UIViewControllerB</span>.m想要重写<span class="built_in">UITableViewDelegate</span></div><div class="line">- 如果代理方法是必须实现的话, <span class="built_in">UIViewControllerB</span>可以直接call [<span class="keyword">super</span> ...]</div><div class="line">- 如果是<span class="keyword">@optional</span>的代理方法, <span class="built_in">UIViewControllerB</span>必须检查<span class="built_in">UIViewControllerA</span>是否有实现	- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;		<span class="built_in">CGFloat</span> retVal = <span class="number">0</span>;		<span class="keyword">if</span> ([[<span class="built_in">UIViewControllerA</span> <span class="keyword">class</span>] instancesRespondToSelector:<span class="keyword">@selector</span>(tableView:heightForRowAtIndexPath:)]) &#123;		retVal = [<span class="keyword">super</span> tableView:<span class="keyword">self</span>.tableView heightForRowAtIndexPath:indexPath];</div><div class="line">		&#125;		<span class="keyword">return</span> retVal + <span class="number">10.0</span>f;</div><div class="line">	&#125;</div><div class="line">参考资料:http:<span class="comment">//devetc.org/code/2014/03/02/subclassing-delegates.html#fn:_cmd-arg(在相同方法中@selector(xxx) == _cmd)</span></div></pre></td></tr></table></figure>
<h4 id="7-多重代理"><a href="#7-多重代理" class="headerlink" title="7.多重代理"></a>7.多重代理</h4><ol>
<li>多个代理对象由一个proxy类来管理,proxy作为委托者的delegate</li>
<li>proxy并没有实现代理回调,所以这里需要使用到运行时的相关方法<br><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170704113634.png" alt="SamuelChan/20170704113634.png"></li>
<li>相关代码  </li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span>)设置proxy代理</div><div class="line">    _multipleDelegate = [MultipleDelegate new];</div><div class="line">    <span class="comment">//添加要处理delegate方法的对象</span></div><div class="line">    <span class="built_in">NSArray</span> *array = @[<span class="keyword">self</span>, [ScrollDelegate new]];</div><div class="line">    _multipleDelegate.allDelegates = array;</div><div class="line">    <span class="keyword">self</span>.scrollView.delegate = (<span class="keyword">id</span>)_multipleDelegate;</div><div class="line">(<span class="number">2</span>)防止强引用</div><div class="line">- (<span class="keyword">void</span>)setDelegateTargets:(<span class="built_in">NSArray</span> *)delegateTargets&#123;</div><div class="line">    <span class="keyword">self</span>.weakRefTargets = [<span class="built_in">NSPointerArray</span> weakObjectsPointerArray];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">id</span> delegate <span class="keyword">in</span> delegateTargets) &#123;</div><div class="line">        [<span class="keyword">self</span>.weakRefTargets addPointer:(__bridge <span class="keyword">void</span> *)delegate];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">(<span class="number">3</span>)分发代理方法:</div><div class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector&#123;</div><div class="line">    <span class="built_in">NSMethodSignature</span> *signature = [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</div><div class="line">    <span class="keyword">if</span> (!signature) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> target <span class="keyword">in</span> <span class="keyword">self</span>.allDelegates) &#123;</div><div class="line">            <span class="keyword">if</span> ((signature = [target methodSignatureForSelector:aSelector])) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> signature;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">id</span> target <span class="keyword">in</span> <span class="keyword">self</span>.allDelegates) &#123;</div><div class="line">        <span class="keyword">if</span> ([target respondsToSelector:anInvocation.selector]) &#123;</div><div class="line">            [anInvocation invokeWithTarget:target];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">由于我们调用delegate的方法时，一般会先调用[delegate responseToSelector]方法，所以，我们还需要实现这个方法：</div><div class="line">- (<span class="built_in">BOOL</span>)respondsToSelector:(SEL)aSelector&#123;</div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">super</span> respondsToSelector:aSelector]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">id</span> target <span class="keyword">in</span> <span class="keyword">self</span>.allDelegates) &#123;</div><div class="line">        <span class="keyword">if</span> ([target respondsToSelector:aSelector]) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;  </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p><a href="http://www.cocoachina.com/ios/20151208/14595.html" target="_blank" rel="external">多个代理资料</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;禅与Objective-C编程艺术读书笔记&quot;&gt;&lt;a href=&quot;#禅与Objective-C编程艺术读书笔记&quot; class=&quot;headerlink&quot; title=&quot;禅与Objective-C编程艺术读书笔记&quot;&gt;&lt;/a&gt;禅与Objective-C编程艺术读书笔记&lt;/
    
    </summary>
    
      <category term="Objective-C" scheme="http://yoursite.com/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>应用评价</title>
    <link href="http://yoursite.com/2017/06/15/%E5%BA%94%E7%94%A8%E8%AF%84%E4%BB%B7/"/>
    <id>http://yoursite.com/2017/06/15/应用评价/</id>
    <published>2017-06-15T13:25:52.000Z</published>
    <updated>2017-07-19T12:49:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="应用评价"><a href="#应用评价" class="headerlink" title="应用评价"></a>应用评价</h2><h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!产品经理遵守review GuideLines) &#123;</div><div class="line">    <span class="comment">//Do whatever he want</span></div><div class="line">&#125;<span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">if</span> (iOSVersion &gt;= <span class="number">10.3</span>) &#123;</div><div class="line">        <span class="comment">//使用SKStoreReviewController的requestReview方法</span></div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//1.怎么展示:openUrl SKStoreProductViewController</span></div><div class="line">        <span class="comment">//2.什么时候展示: iRate,服务器控制</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h3><ol>
<li>每个应用在App store上面都会有用户的评价和评分  </li>
<li>评价和评分越高的应用将会被优先展示,排名提高.所以才有那么多人刷榜,尤其是游戏,但是从iOS11开始的App store将只会展示每个分类下前三个应用  </li>
<li>在2017.6苹果更新了Review GuideLines,强制要求开发者使用iOS 10.3引入的api:<code>SKStoreReviewController的requestReview方法</code>, 也就是说iOS 10.3之后的版本弹出的框应用使用这个api,一旦发现会被拒绝,<strong>可是很明显审核的时候是很难发现的</strong>.</li>
</ol>
<blockquote>
<p>1.1.7 App Store Reviews:<br>  App Store customer reviews can be an integral part of the app experience, so you should treat customers with respect when responding to their comments. Keep your responses targeted to the user’s comments and do not include personal information, spam, or marketing in your response.<br>Use the provided API to prompt users to review your app; this functionality allows customers to provide an App Store rating and review without the inconvenience of leaving your app, and we will disallow custom review prompts.</p>
</blockquote>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="iOS-10-3之前实现应用内评价的方法"><a href="#iOS-10-3之前实现应用内评价的方法" class="headerlink" title="iOS 10.3之前实现应用内评价的方法"></a><code>iOS 10.3之前</code>实现应用内评价的方法</h4><p>怎么展示:  </p>
<ol>
<li>现在应用最多的做法:弹出一个UIAlertView,三个button,但是其中两个都是会跳到app store的  </li>
</ol>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">	UIAlertView *alertView = [[UIAlertView alloc] <span class="string">initWithTitle:</span>@<span class="string">"程序猿奋力出新版"</span> <span class="string">message:</span>@<span class="string">"打滚儿求好评"</span> <span class="string">delegate:</span>self <span class="string">cancelButtonTitle:</span>@<span class="string">"残忍拒绝"</span> <span class="string">otherButtonTitles:</span>@<span class="string">"好评(跳App store)"</span>,@<span class="string">"吐槽(跳App store)"</span>,nil];</div><div class="line">	[alertView show];</div><div class="line"></div><div class="line"><span class="comment">//在UIAlertViewDelegate中</span></div><div class="line"><span class="comment">//支持直接跳转到AppStore的评论编辑页:通过在项目 URL 查询参数的最后加上 action=write-review 就可以跳转到 AppStore 并自动模态打开评论编辑页面。在此之前我们只能跳转到评论页。</span></div><div class="line">	NSURL *url = [NSURL <span class="string">URLWithString:</span>@<span class="string">"http://itunes.apple.com/WebObjects/MZStore.woa/wa/viewContentsUserReviews?id=1014844521&amp;pageNumber=0&amp;sortOrdering=2&amp;type=Purple+Software&amp;mt=8&amp;action=write-review"</span>];</div><div class="line">	<span class="keyword">if</span>([[UIApplication sharedApplication] <span class="string">canOpenURL:</span>url])&#123;</div><div class="line">        [[UIApplication sharedApplication] <span class="string">openURL:</span>url];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>2.在页面中Modal出一个SKStoreProductViewController,用户在应用即可完成评分和评论  </p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;StoreKit/StoreKit.h&gt;</span></span></div><div class="line"></div><div class="line">    <span class="built_in">SKStoreProductViewController</span> *storeProductVC = [[<span class="built_in">SKStoreProductViewController</span> alloc]init];</div><div class="line">    storeProductVC.delegate = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">    [storeProductVC loadProductWithParameters:@&#123;<span class="built_in">SKStoreProductParameterITunesItemIdentifier</span>:<span class="string">@"1014844521"</span>&#125; completionBlock:^(<span class="built_in">BOOL</span> result, <span class="built_in">NSError</span> * _Nullable error) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (error) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[error localizedDescription]);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"加载完成"</span>);</div><div class="line">            [<span class="keyword">self</span> presentViewController:storeProductVC animated:<span class="literal">YES</span> completion:^&#123;</div><div class="line">                <span class="built_in">NSLog</span>(<span class="string">@"界面弹出完成"</span>);</div><div class="line">            &#125;];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    <span class="comment">//modal出来的页面点击"取消"的回调</span></div><div class="line">	- (<span class="keyword">void</span>)productViewControllerDidFinish:(<span class="built_in">SKStoreProductViewController</span> *)viewController&#123;</div><div class="line">    [<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>什么时候展示:<br>1.<a href="https://github.com/nicklockwood/iRate" target="_blank" rel="external">iRate</a>:提供了丰富的自定义弹出规则,之前我就是使用这个来做</p>
<p>2.服务器来控制弹出的时机</p>
<h4 id="iOS-10-3之后实现应用内评价的方法"><a href="#iOS-10-3之后实现应用内评价的方法" class="headerlink" title="iOS 10.3之后实现应用内评价的方法"></a><code>iOS 10.3之后</code>实现应用内评价的方法</h4><p><a href="https://developer.apple.com/app-store/ratings-and-reviews/" target="_blank" rel="external">官方文档看这里</a>  </p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="section">[SKStoreReviewController requestReview]</span><span class="comment">;</span></div></pre></td></tr></table></figure>
<p><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170619174141.png?imageView2/2/w/480/h/360/q/99|imageslim" alt="SamuelChan/20170619174141.png"></p>
<p>Feature:  </p>
<ol>
<li>只有评分,没有评论  </li>
<li>弹出完全由苹果控制,所以不能在手势/按钮点击回调中使用这个api,你并不知道有没有弹出  </li>
<li>每年只会弹出三次  </li>
<li>只会在最新版本中弹出,低版本调用了这个api也不会弹出  </li>
<li>在debug环境下,该框会一直弹出,TestFlight该方法无效</li>
<li>关闭:如下图<br><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170619221921.png?imageView2/2/w/360/h/200/q/99|imageslim" alt="SamuelChan/20170619221921.png"></li>
</ol>
<h3 id="我的方案"><a href="#我的方案" class="headerlink" title="我的方案"></a>我的方案</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">if</span> ([<span class="built_in">UIDevice</span> currentDevice].systemVersion.floatValue &gt;= <span class="number">10.3</span>) &#123;</div><div class="line">     [<span class="keyword">self</span> inAppSKStoreReviewController];   </div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line"><span class="comment">//自定义弹出规则比如iRate,</span></div><div class="line">[[iRate shareInstance] logEvent:<span class="literal">NO</span>]</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>我从来都没有被弹出框引导去评价,都是直接关掉的;可以有了10.3的api又有多少产品经理会遵守呢…</li>
<li>这篇文章make no sense,只是用来练手的 哈哈</li>
</ol>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://sspai.com/post/38673" target="_blank" rel="external">具透丨iOS 10.3 新 App Store 评价机制详解</a><br><a href="https://9to5mac.com/2017/06/09/app-rating-custom-prompts-app-store-banned/" target="_blank" rel="external">App Store now requires developers to use official API to request app ratings, disallows custom prompts</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;应用评价&quot;&gt;&lt;a href=&quot;#应用评价&quot; class=&quot;headerlink&quot; title=&quot;应用评价&quot;&gt;&lt;/a&gt;应用评价&lt;/h2&gt;&lt;h3 id=&quot;summary&quot;&gt;&lt;a href=&quot;#summary&quot; class=&quot;headerlink&quot; title=&quot;sum
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
</feed>
