<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Samuel blog</title>
  <subtitle>SamuelChan</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-07-19T11:24:27.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>SamuelChan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/07/19/hello-world/"/>
    <id>http://yoursite.com/2017/07/19/hello-world/</id>
    <published>2017-07-19T03:44:34.000Z</published>
    <updated>2017-07-19T11:24:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
      <category term="test" scheme="http://yoursite.com/categories/test/"/>
    
    
  </entry>
  
  <entry>
    <title>Pro.Multithreading.and.Memory.Management.for.iOS.and.OS.X(MRC和ARC)</title>
    <link href="http://yoursite.com/2017/07/06/Pro.Multithreading.and.Memory.ManageMent.for.iOS.and.OS.X/"/>
    <id>http://yoursite.com/2017/07/06/Pro.Multithreading.and.Memory.ManageMent.for.iOS.and.OS.X/</id>
    <published>2017-07-06T06:56:56.000Z</published>
    <updated>2017-07-20T10:04:31.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Problems:  </p>
<ol>
<li>一个非alloc/new/copy/muteCopy返回对象的方法应该由谁管理内存?  </li>
<li>AutoReleasePool也需要进行内存管理吗?如果要,谁来管理?</li>
</ol>
</blockquote>
<hr>
<h3 id="Chapter1-Life-Before-Automatic-Reference-Counting"><a href="#Chapter1-Life-Before-Automatic-Reference-Counting" class="headerlink" title="Chapter1 Life Before Automatic Reference Counting"></a>Chapter1 Life Before Automatic Reference Counting</h3><hr>
<h4 id="Reference-Counted-Memory-Management-Overview"><a href="#Reference-Counted-Memory-Management-Overview" class="headerlink" title="Reference Counted Memory Management Overview"></a>Reference Counted Memory Management Overview</h4><ol>
<li>Memory Management(means Reference Counting in OC) : a programmer allocates a memory area when the program needs it and frees it when the program no longer needs it.  </li>
<li>Reference Counting: invented by George E. Collins in 1960</li>
<li>With Reference Counting,you don’t need to remember the value of the reference counter itself or what refers to the object<br><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170706152431.png" alt="SamuelChan/20170706152431.png"></li>
</ol>
<h4 id="Exploring-Memory-Management-Further"><a href="#Exploring-Memory-Management-Further" class="headerlink" title="Exploring Memory Management Further"></a>Exploring Memory Management Further</h4><ol>
<li>Reference Counting Rules:<ul>
<li>You have ownership of any objects you create.</li>
<li>You can take ownership of an object using retain.</li>
<li>When no longer needed, you must relinquish ownership of an object you own.</li>
<li>You must not relinquish ownership of an object you don’t own.</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>Action for Objective-C Object</th>
<th>Objective-C Method</th>
</tr>
</thead>
<tbody>
<tr>
<td>Create and have ownership of it</td>
<td>alloc/new/copy/mutableCopy group</td>
</tr>
<tr>
<td>Take ownership of it</td>
<td>retain</td>
</tr>
<tr>
<td>Relinquish it</td>
<td>release</td>
</tr>
<tr>
<td>Dispose of it</td>
<td>dealloc</td>
</tr>
</tbody>
</table>
<blockquote>
<p>these method(alloc, retain, release, and dealloc) are not provided by the Objective-C language itself.They are features of the Foundation Framework as part of Cocoa Framework<br><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170706154549.png" alt="SamuelChan/20170706154549.png"></p>
</blockquote>
<h5 id="You-Have-Ownership-of-Any-Objects-You-Create"><a href="#You-Have-Ownership-of-Any-Objects-You-Create" class="headerlink" title="You Have Ownership of Any Objects You Create"></a>You Have Ownership of Any Objects You Create</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// You create an object and have ownership.</span></div><div class="line"><span class="keyword">id</span> obj     = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"><span class="keyword">id</span> obj     = [<span class="built_in">NSObject</span> new];</div><div class="line"><span class="keyword">id</span> objNew1 = [obj <span class="keyword">copy</span>];<span class="comment">//NSCopying protocol:copyWithZone:</span></div><div class="line"><span class="keyword">id</span> objNew2 = [obj mutableCopy];<span class="comment">//NSMutableCopying protocol:mutableCopyWithZone:</span></div><div class="line"><span class="comment">//the naming convention is applied to:</span></div><div class="line">  allocMyObject newThatObject copyThis mutableCopyYourObject</div><div class="line"><span class="comment">//the naming convention is not applied to:</span></div><div class="line">  allocate  newer  copying  mutableCopyed</div></pre></td></tr></table></figure>
<h5 id="You-Can-Take-Ownership-of-an-Object-Using-retain"><a href="#You-Can-Take-Ownership-of-an-Object-Using-retain" class="headerlink" title="You Can Take Ownership of an Object Using retain"></a>You Can Take Ownership of an Object Using retain</h5><p>Sometimes methods that are not in the alloc/new/copy/mutableCopy method group return an object : you haven’t create it, so you don’t have ownership of it.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Obtain an object without creating it yourself or having ownership   </span></div><div class="line"></div><div class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"><span class="comment">// The obtained object exists and you don’t have ownership of it,but you have a reference to NSMutableArray object.</span></div><div class="line"></div><div class="line">[obj <span class="keyword">retain</span>];</div><div class="line"><span class="comment">// The obtained object exists and you don’t have ownership of it.</span></div></pre></td></tr></table></figure>
<h5 id="When-No-Longer-Needed-You-Must-Relinquish-Ownership-of-an-Object-You-Own"><a href="#When-No-Longer-Needed-You-Must-Relinquish-Ownership-of-an-Object-You-Own" class="headerlink" title="When No Longer Needed, You Must Relinquish Ownership of an Object You Own"></a>When No Longer Needed, You Must Relinquish Ownership of an Object You Own</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1.alloc -&gt; relinquish</span></div><div class="line"><span class="comment">// You create an object and have ownership.</span></div><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"><span class="comment">// Now you have ownership of the object.</span></div><div class="line">[obj release];</div><div class="line"><span class="comment">// The object is relinquished.Though the variable obj has the pointer to the object,you can’t access the object anymore.</span></div><div class="line"></div><div class="line"><span class="comment">// 2.retain -&gt; relinquish</span></div><div class="line"><span class="comment">// Obtain an object without creating it yourself or having ownership</span></div><div class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"><span class="comment">// The obtained object exists and you don’t have ownership of it.</span></div><div class="line">[obj <span class="keyword">retain</span>];</div><div class="line"><span class="comment">// Now you have ownership of the object.</span></div><div class="line">[obj release];</div><div class="line"><span class="comment">// The object is relinquished.You can’t access the object anymore.</span></div></pre></td></tr></table></figure>
<p><strong>how a method return a created object?</strong></p>
<ol>
<li>alloc/new/copy/muteableCopy : <strong>If a method returns an object of which the methodhasownership,ownership is passed to the caller</strong></li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)allocObject &#123;</div><div class="line">  <span class="comment">// You create an object and have ownership.</span></div><div class="line">  <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">  <span class="comment">// At this moment, this method has ownership of the object.</span></div><div class="line">  <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>[NSMutableArray array] : Returning a New Object Without Ownership.<strong>By calling autorelease, you can return the created object without ownership</strong> 可以返回,而不是为什么要返回没有ownership的(means by design)</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)object &#123;</div><div class="line">  <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">  <span class="comment">/* At this moment, this method has ownership of the object. */</span></div><div class="line"></div><div class="line">  [obj autorelease];</div><div class="line">  <span class="comment">/* The object exists, and you don’t have ownership of it. */</span></div><div class="line">  <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170706173000.png" alt="SamuelChan/20170706173000.png"></p>
<h5 id="You-Must-Not-Relinquish-Ownership-of-an-Object-You-Don’t-Own"><a href="#You-Must-Not-Relinquish-Ownership-of-an-Object-You-Don’t-Own" class="headerlink" title="You Must Not Relinquish Ownership of an Object You Don’t Own"></a>You Must Not Relinquish Ownership of an Object You Don’t Own</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">[obj release];</div><div class="line">[obj release];<span class="comment">//crash</span></div><div class="line"></div><div class="line"><span class="keyword">id</span> obj1 = [obj0 object];</div><div class="line">[obj1 release];<span class="comment">//crash sooner or later</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/** why retainCount = -1 ? */</span></div><div class="line"><span class="keyword">id</span> obj2 = [<span class="built_in">NSArray</span> array];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,[obj2 retainCount]);</div><div class="line"></div><div class="line"><span class="keyword">id</span> obj4 = [<span class="built_in">NSString</span> string];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,[obj4 retainCount]);</div></pre></td></tr></table></figure>
<h4 id="Implementing-alloc-retain-release-and-dealloc"><a href="#Implementing-alloc-retain-release-and-dealloc" class="headerlink" title="Implementing alloc, retain, release, and dealloc"></a>Implementing alloc, retain, release, and dealloc</h4><p>Although opensourced, I think this <code>guess</code> procedure still worth of being read so HERE WE GO.  </p>
<ol>
<li><del> But still, without having the implementation of NSObject itself, it is hard to see the whole picture </del>  :   <a href="https://github.com/opensource-apple/objc4" target="_blank" rel="external">NSObject has been opensource</a>  </li>
<li>CFFoundation is open-source,and the source code for memory management that is used from NSObject is public  </li>
<li><a href="https://en.wikipedia.org/wiki/GNUstep" target="_blank" rel="external">GNUstep</a> is a free software implementation of the Cocoa (formerly OpenStep) Objective-C frameworks, widget toolkit, and application development tools for Unix-like operating systems and Microsoft Windows. It is part of the GNU Project.Although we can’t expect it to be exactly the same as Apple’s implementation, it works in the same manner and the implementation should be similar.<strong>Understanding GNUstep source code helps us guess Apple’s Cocoa implementation</strong></li>
</ol>
<h5 id="GNUStep-implementation"><a href="#GNUStep-implementation" class="headerlink" title="GNUStep implementation"></a>GNUStep implementation</h5><p>1.The alloc Method</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> obj_layout &#123;</div><div class="line">	<span class="built_in">NSUInteger</span> retained;</div><div class="line">&#125;;</div><div class="line">+ (<span class="keyword">id</span>) alloc &#123;</div><div class="line">	<span class="keyword">int</span> size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> obj_layout) + size_of_the_object;</div><div class="line">	<span class="comment">//在堆上，分配n*size个字节，并初始化为0，返回void* 类型</span></div><div class="line">	<span class="keyword">struct</span> obj_layout *p = (<span class="keyword">struct</span> obj_layout *)calloc(<span class="number">1</span>, size);</div><div class="line">	<span class="keyword">return</span> (<span class="keyword">id</span>)(p + <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.The retain Method<br><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170707105639.png" alt="SamuelChan/20170707105639.png"></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSUInteger</span>) retainCount &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">NSExtraRefCount</span>(<span class="keyword">self</span>) + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">inline</span> <span class="built_in">NSUInteger</span> <span class="built_in">NSExtraRefCount</span>(<span class="keyword">id</span> anObject)&#123;</div><div class="line">    <span class="keyword">return</span> ((<span class="keyword">struct</span> obj_layout *)anObject)[<span class="number">-1</span>].retained; <span class="comment">//移到头部</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>) <span class="keyword">retain</span> &#123;</div><div class="line">    <span class="built_in">NSIncrementExtraRefCount</span>(<span class="keyword">self</span>);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="built_in">NSIncrementExtraRefCount</span>(<span class="keyword">id</span> anObject) &#123;   <span class="keyword">if</span> (((<span class="keyword">struct</span> obj_layout *)anObject)[<span class="number">-1</span>].retained == <span class="built_in">UINT_MAX</span> - <span class="number">1</span>)   [<span class="built_in">NSException</span> raise: <span class="built_in">NSInternalInconsistencyException</span> format: <span class="string">@"NSIncrementExtraRefCount() asked increment too far"</span>];   ((<span class="keyword">struct</span> obj_layout *)anObject)[<span class="number">-1</span>].retained++;&#125;</div></pre></td></tr></table></figure>
<p>3.The release Method</p>
<pre><code class="objc">- (<span class="keyword">void</span>) release {
  <span class="keyword">if</span> (<span class="built_in">NSDecrementExtraRefCountWasZero</span>(<span class="keyword">self</span>))
  [<span class="keyword">self</span> dealloc]; <span class="comment">//dispose it</span>
}

<span class="built_in">BOOL</span> <span class="built_in">NSDecrementExtraRefCountWasZero</span>(<span class="keyword">id</span> anObject) {
  <span class="keyword">if</span> (((<span class="keyword">struct</span> obj_layout *)anObject)[<span class="number">-1</span>].retained == <span class="number">0</span>) {
    <span class="keyword">return</span> <span class="literal">YES</span>;
  } <span class="keyword">else</span> {
    ((<span class="keyword">struct</span> obj_layout *)anObject)[<span class="number">-1</span>].retained--;
    <span class="keyword">return</span> <span class="literal">NO</span>;
  }
}
</code></pre>
<p>4.The dealloc Method</p>
<pre><code class="objc">- (<span class="keyword">void</span>) dealloc {
  <span class="built_in">NSDeallocateObject</span> (<span class="keyword">self</span>);
}

<span class="keyword">inline</span> <span class="keyword">void</span> <span class="built_in">NSDeallocateObject</span>(<span class="keyword">id</span> anObject) {
  <span class="keyword">struct</span> obj_layout *o = &amp;((<span class="keyword">struct</span> obj_layout *)anObject)[<span class="number">-1</span>];
  free(o);
}
</code></pre>
<h5 id="Apple’s-Implementation-of-alloc-retain-release-and-dealloc"><a href="#Apple’s-Implementation-of-alloc-retain-release-and-dealloc" class="headerlink" title="Apple’s Implementation of alloc, retain, release, and dealloc"></a>Apple’s Implementation of alloc, retain, release, and dealloc</h5><p>1.The alloc method</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+alloc</div><div class="line">+allocWithZone:</div><div class="line">class_createInstance</div><div class="line">calloc</div></pre></td></tr></table></figure>
<p>2.retainCount, retain, and release</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">-retainCount</div><div class="line">__CFDoExternRefOperation</div><div class="line"><span class="built_in">CFBasicHashGetCountOfKey</span></div><div class="line"></div><div class="line">-<span class="keyword">retain</span></div><div class="line">__CFDoExternRefOperation</div><div class="line"><span class="built_in">CFBasicHashAddValue</span></div><div class="line"></div><div class="line">-release</div><div class="line">__CFDoExternRefOperation</div><div class="line"><span class="built_in">CFBasicHashRemoveValue</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> __CFDoExternRefOperation(uintptr_t op, <span class="keyword">id</span> obj) &#123;</div><div class="line">  	<span class="built_in">CFBasicHashRef</span> table = get hashtable from obj;</div><div class="line">    <span class="keyword">int</span> count;</div><div class="line">    <span class="keyword">switch</span> (op) &#123;</div><div class="line">      <span class="keyword">case</span> OPERATION_retainCount:</div><div class="line">        count = <span class="built_in">CFBasicHashGetCountOfKey</span>(table, obj);</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">      <span class="keyword">case</span> OPERATION_retain:</div><div class="line">        <span class="built_in">CFBasicHashAddValue</span>(table, obj);</div><div class="line">        <span class="keyword">return</span> obj;</div><div class="line">      <span class="keyword">case</span> OPERATION_release:</div><div class="line">        count = <span class="built_in">CFBasicHashRemoveValue</span>(table, obj);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span> == count;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">NSUInteger</span>) retainCount &#123;</div><div class="line">  	<span class="keyword">return</span> (<span class="built_in">NSUInteger</span>)__CFDoExternRefOperation(OPERATION_retainCount, <span class="keyword">self</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>) <span class="keyword">retain</span> &#123;</div><div class="line">  <span class="keyword">return</span> (<span class="keyword">id</span>)__CFDoExternRefOperation(OPERATION_retain, <span class="keyword">self</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>) release &#123;</div><div class="line">  <span class="keyword">return</span> __CFDoExternRefOperation(OPERATION_release, <span class="keyword">self</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3.Apple implementation vs GNUStep implementation<br>Benefits:<br>GNUStep implementation:    </p>
<ul>
<li>Fewer codes  </li>
<li>It is quite simple to manage the lifetime, because each memory area of the reference count itself is included in the object memory area</li>
</ul>
<p>Apple implementation:</p>
<ul>
<li>Each object doesn’t have a header, thus there is no need to worry about alignment issues for the header area</li>
<li>By iterating through the hash table entries, memory blocks for each object are reachable.(useful for debugging,LLDB and Instruments)</li>
</ul>
<p><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170707113104.png" alt="SamuelChan/20170707113104.png"><br><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170707113946.png" alt="SamuelChan/20170707113946.png"></p>
<h4 id="Autorelease"><a href="#Autorelease" class="headerlink" title="Autorelease"></a>Autorelease</h4><p>1.Automatic Variables in C language:when left the variable scope,auto variable ‘int a’ is disposed of and can’t be accessed anymore.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.autoRelease:when execution leaves a code block, the “release” method is called on the object automatically</p>
<p>3.Caution:<br>(1)临时处理多个对象的释放<br>(2)类方法返回来一个没有ownership的对象<br>(3)不要对NSAutoReleasePool发送autoRelease方法,因为它已经被override抛出exception  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1. Create an NSAutoreleasePool object.</span></div><div class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</div><div class="line"></div><div class="line"><span class="comment">//2. Call “autorelease” to allocated objects.</span></div><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">[obj autorelease];</div><div class="line"></div><div class="line"><span class="comment">//3. Discard the NSAutoreleasePool object.</span></div><div class="line">[pool drain];<span class="comment">//will do [obj release]</span></div></pre></td></tr></table></figure>
<p><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170707141849.png" alt="SamuelChan/20170707141849.png">  </p>
<p>No need to explicitly use the NSAutoreleasePool object in <code>the main Runloop</code>  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170707142124.png" alt="SamuelChan/20170707142124.png">  </p>
<h5 id="Implementing-autorelease"><a href="#Implementing-autorelease" class="headerlink" title="Implementing autorelease"></a>Implementing autorelease</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoreleasePoolPage</span> &#123;</span></div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">push</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">/* It corresponds to creation and ownership of an NSAutoreleasePool object */</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span> *token)</span> </span>&#123;</div><div class="line">    <span class="comment">/* It corresponds to disposal of an NSAutoreleasePool object */</span></div><div class="line">    releaseAll();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> id <span class="title">autorelease</span><span class="params">(id obj)</span> </span>&#123;</div><div class="line">    <span class="comment">/* It corresponds to NSAutoreleasePool class method addObject. */</span></div><div class="line">    AutoreleasePoolPage *autoreleasePoolPage = <span class="comment">/* getting active 	AutoreleasePoolPage object */</span></div><div class="line">    autoreleasePoolPage-&gt;add(obj);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function">id *<span class="title">add</span><span class="params">(id obj)</span> </span>&#123;</div><div class="line">    <span class="comment">/* add the obj to an internal array; */</span> &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">releaseAll</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="comment">/* calls release for all the objects in the internal array */</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">objc_autoreleasePoolPush</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> AutoreleasePoolPage::push();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_autoreleasePoolPop</span><span class="params">(<span class="keyword">void</span> *ctxt)</span> </span>&#123;</div><div class="line">  AutoreleasePoolPage::pop(ctxt);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">id <span class="title">objc_autorelease</span><span class="params">(id obj)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> AutoreleasePoolPage::autorelease(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Chapter2-ARC-Rules"><a href="#Chapter2-ARC-Rules" class="headerlink" title="Chapter2 ARC Rules"></a>Chapter2 ARC Rules</h3><blockquote>
<p>Apple: Automatic Reference Counting (ARC) in Objective-C makes memory management the job of the compiler. By enabling ARC with the new Apple LLVM compiler, you will never need to type retain or release again, dramatically simplifying the development process, while reducing crashes and memory leaks. The compiler has a complete understanding of your objects, and releases each object the instant it is no longer used, so apps run as fast as ever, with predictable, smooth performance.1</p>
</blockquote>
<p>ARC related:</p>
<ul>
<li>iOS 5 2011  </li>
<li>Xcode Version &gt;= 4.2  </li>
<li>LLVM version  &gt;= 3.0  </li>
<li>Objective-C runtime library: objc4 493.9 or later</li>
<li>ARC enabled: 1.Enabled ARC in build Setting 2.部分MRC:Build phases→Compile Sources→ -fno-objc-arc 3. Build phases→Compile Sources→部分ARC:-fobjc-arc<br><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170717103437.png" alt="SamuelChan/20170717103437.png"></li>
</ul>
<p>Chapter2组织方式:  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- the relationship of the reference counting rules with ARC  </div><div class="line">- the ownership specifiers one by one  </div><div class="line">- we learn the rules to make your code ARC-friendly: by simply following the rules</div></pre></td></tr></table></figure>
<h4 id="Ownership-qualifiers"><a href="#Ownership-qualifiers" class="headerlink" title="Ownership qualifiers"></a>Ownership qualifiers</h4><blockquote>
<p>With ARC,, ‘id’ and object type variables <mark><strong>must</strong></mark> have one of the following four ownership qualifiers:</p>
</blockquote>
<ul>
<li>__strong  </li>
<li>__weak  </li>
<li>__unsafe _unretained     </li>
<li>__autoreleasing</li>
</ul>
<h5 id="1-strong-ownership-qualifier"><a href="#1-strong-ownership-qualifier" class="headerlink" title="1.__strong ownership qualifier"></a>1.__strong ownership qualifier</h5><ul>
<li><p>__strong 代表了对象的ownership (MRC下对象需要通过alloc/new/copy/muteableCopy或者retain来获得ownership)</p>
</li>
<li><p>__strong离开了{ }之后就会消失,即是说作用域在{ }之间</p>
</li>
<li><p>一个对象没有ownership将会被disposed</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* non-ARC */</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">  [obj release];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* ARC */</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">id</span> __<span class="keyword">strong</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">  <span class="keyword">id</span> __<span class="keyword">strong</span> obj = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//ownership is properly managed not only by variable scope, but also by assignments between variables</span></div><div class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj0 = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj1 = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj2 = <span class="literal">nil</span>;</div><div class="line">obj0 = obj1;</div><div class="line">obj2 = obj0;</div><div class="line">obj1 = <span class="literal">nil</span>;</div><div class="line">obj0 = <span class="literal">nil</span>;</div><div class="line">obj2 = <span class="literal">nil</span>;</div><div class="line"></div><div class="line"><span class="comment">//By the way, any variables that are qualified with __strong, __weak, and __autoreleasing, are initialized with nil</span></div><div class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj0;</div><div class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> obj1;</div><div class="line"><span class="keyword">id</span> __autoreleasing obj2;</div><div class="line">The above source code is equivalent to the following.</div><div class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj0 = <span class="literal">nil</span>;</div><div class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = <span class="literal">nil</span>;</div><div class="line"><span class="keyword">id</span> __autoreleasing obj2 = <span class="literal">nil</span>;</div></pre></td></tr></table></figure>
<h5 id="2-weak-ownership-qualifier"><a href="#2-weak-ownership-qualifier" class="headerlink" title="2.__weak ownership qualifier"></a>2.__weak ownership qualifier</h5><blockquote>
<p>solve circular reference,self reference: A weak reference does not have ownership of the object.</p>
<p>When a variable has a reference to an object and the object is discarded, the weak reference also disappears automatically, which means that the variable is assigned to <mark>nil</mark>.</p>
</blockquote>
<p><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170711111007.png" alt="SamuelChan/20170711111007.png"></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> obj = [[<span class="built_in">NSObject</span> alloc] init];<span class="comment">//wrong,</span></div><div class="line"><span class="comment">//warning: assigning retained obj to weak variable; obj will be released after assignment [-Warc-unsafe-retained-assign]</span><span class="keyword">id</span> __<span class="keyword">strong</span> obj0 = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = obj0;</div></pre></td></tr></table></figure>
<h5 id="3-unsafe-unretained-ownership-qualifier"><a href="#3-unsafe-unretained-ownership-qualifier" class="headerlink" title="3.__unsafe_unretained ownership qualifier"></a>3.__unsafe_unretained ownership qualifier</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">__<span class="keyword">weak</span>               : iOS5 (or later) or OSX Lion (or later)</div><div class="line">__unsafe _unretained : before iOS5 or before OSX Lion</div><div class="line"></div><div class="line"><span class="comment">//__weak和__unsafe_unretained的区别在于:后者不会在对象无ownership之后自动置为nil</span></div><div class="line"><span class="keyword">id</span> __<span class="keyword">unsafe_unretained</span> obj1 = <span class="literal">nil</span>;</div><div class="line">&#123;</div><div class="line">  <span class="keyword">id</span> __<span class="keyword">strong</span> obj0 = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">  obj1 = obj0;</div><div class="line">  <span class="built_in">NSLog</span>(<span class="string">@"A: %@"</span>, obj1);</div><div class="line">&#125;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"B: %@"</span>, obj1);<span class="comment">//Crash:野指针,访问僵尸对象,报EXC_BAD_ADDRESS</span></div><div class="line"></div><div class="line">FYI:</div><div class="line">（<span class="number">1</span>）野指针</div><div class="line">①C语言:定义了一个指针变量，但是并没有赋初值，它随机指向一个东西</div><div class="line">②Obj某指针变量指向的内存空间被释放掉了（指向僵尸对象的指针）</div><div class="line"></div><div class="line">（<span class="number">2</span>）僵尸对象</div><div class="line">已经被销毁的对象（无法被使用的对象）</div><div class="line"></div><div class="line">（<span class="number">3</span>）空指针</div><div class="line">没有指向存储空间的指针（里面存的是<span class="literal">nil</span>，也就是<span class="number">0</span>）</div><div class="line">给空指针发消息是没有任何反应的，不会提示出错</div><div class="line"></div><div class="line">(<span class="number">4</span>) EXC_BAD_ADDRESS ARC什么时候会出现?? Core-Foundation,混编,C++</div></pre></td></tr></table></figure>
<h5 id="4-autoreleasing-ownership-qualifier"><a href="#4-autoreleasing-ownership-qualifier" class="headerlink" title="4.__autoreleasing ownership qualifier"></a>4.__autoreleasing ownership qualifier</h5><p><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170711144133.png" alt="SamuelChan/20170711144133.png"><br><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170711144249.png" alt="SamuelChan/20170711144249.png"></p>
<ul>
<li><p>①When an object is returned from a method, the compiler checks if the method begins with alloc/new/copy/mutableCopy, and if not, the returned object is automatically registered to the autorelease pool</p>
</li>
<li><p>②Exceptionally, any method whose name begins with init, doesn’t register the return value to autoreleasepool</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@autoreleasepool</span> &#123;</div><div class="line"><span class="comment">//not in the alloc/new/copy/mutableCopy method group,register in autoReleasePool</span>	<span class="keyword">id</span> __<span class="keyword">strong</span> obj = [<span class="built_in">NSMutableArray</span> array];&#125;</div><div class="line"></div><div class="line"><span class="comment">//“id obj” does not have a qualifier. So it is qualified with __strong. When the “return” sentence is executed, the variable scope is left and the strong reference disappears. Therefore the object will be released automatically. Before that, if the compiler detects that the object will be passed to the caller, the object is registered in autoreleasepool.</span></div><div class="line"></div><div class="line">+ (<span class="keyword">id</span>) array &#123;</div><div class="line">  <span class="keyword">id</span> obj = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line">  <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>③<del>the <strong>weak ownership qualifier is used to avoid cyclic reference. When a variable with a </strong>weak qualifier is used, the object is always registered in autoreleasepool.</del>  </p>
<p>  <del> Why does the object need to be registered in autoreleasepool in order to use the object via the <strong>weak qualified variable? Because a variable, which is qualified with </strong>weak,<br>does not have a strong reference, the object might be disposed of at any point. If the object is registered in autoreleasepool, until @autoreleasepool block is left, the object must exist. So, to use the objects via __weak variable safely, the object is registered in autoreleasepool automatically.(<strong>to be proved</strong>) </del></p>
</li>
<li><p>④ Any pointers to ‘id’ or object types are qualified with __autoreleasing as default.  </p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj 	       == <span class="keyword">id</span> __<span class="keyword">strong</span> obj;  </div><div class="line"><span class="keyword">id</span> *obj   	   == <span class="keyword">id</span> __autoreleasing *obj;  </div><div class="line"><span class="built_in">NSObject</span> **obj == <span class="built_in">NSObject</span> * __autoreleasing *obj  </div><div class="line">-(<span class="built_in">BOOL</span>) performOperationWithError:(<span class="built_in">NSError</span> * __autoreleasing *)error;</div></pre></td></tr></table></figure>
<p>5.Returning a Result as the Argument</p>
<blockquote>
<p>The caller will obtain the object as an argument, which means that the caller does not obtain it from the alloc/new/copy/mutableCopy method group. To follow the memory management rules, <mark>when you do not obtain an object by the alloc/new/copy/mutableCopy method group, the object has to be passed without ownership.</mark> By the __autoreleasing ownership qualifier, the rule is fulfilled.</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>) performOperationWithError:(<span class="built_in">NSError</span> * __autoreleasing *)error &#123;</div><div class="line">  <span class="comment">/* Error occurred. Set errorCode */</span></div><div class="line">  <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//To assign an object pointer, both ownership qualifiers have to be the same.</span></div><div class="line"><span class="built_in">NSError</span> __autoreleasing *error = <span class="literal">nil</span>;</div><div class="line"><span class="built_in">NSError</span> * __autoreleasing *pError = &amp;error; <span class="comment">/* No compile error */</span></div><div class="line"></div><div class="line"><span class="comment">//compile optimization(before)</span></div><div class="line"><span class="built_in">NSError</span> __<span class="keyword">strong</span> *error = <span class="literal">nil</span>;</div><div class="line"><span class="built_in">BOOL</span> result = [obj performOperationWithError:&amp;error];</div><div class="line"></div><div class="line"><span class="comment">//compile optimization(after)</span></div><div class="line"><span class="built_in">NSError</span> __<span class="keyword">strong</span> *error = <span class="literal">nil</span>;</div><div class="line"><span class="built_in">NSError</span> __autoreleasing *tmp = error;</div><div class="line"><span class="built_in">BOOL</span> result = [obj performOperationWithError:&amp;tmp];</div><div class="line">error = tmp;</div></pre></td></tr></table></figure>
<h4 id="Rules"><a href="#Rules" class="headerlink" title="Rules"></a>Rules</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span>Forget about using <span class="keyword">retain</span>, release, retainCount, and autorelease.</div><div class="line"><span class="number">2.</span>Forget about using <span class="built_in">NSAllocateObject</span> and <span class="built_in">NSDeallocateObject</span>.</div><div class="line"><span class="number">3.</span>Follow the naming rule <span class="keyword">for</span> methods related to object creation:</div><div class="line">  create ownership:alloc/new/<span class="keyword">copy</span>/mutableCopy/- (instanceType)initWithXXX</div><div class="line"><span class="number">4.</span>Forget about calling dealloc explicitly.</div><div class="line">  dealloc is a suitable place to remove the object from delegate or observers</div><div class="line"><span class="number">5.</span>Use <span class="keyword">@autoreleasepool</span> instead of <span class="built_in">NSAutoreleasePool</span>.</div><div class="line"><span class="number">6.</span>Forget about using Zone (<span class="built_in">NSZone</span>)</div><div class="line">  现在CPU的负载能力不需要<span class="built_in">NSZone</span>这种会带来碎片化的机制</div><div class="line"><span class="number">7.</span>Object type variables can’t be members of <span class="keyword">struct</span> or <span class="keyword">union</span> <span class="keyword">in</span> C language.</div></pre></td></tr></table></figure>
<p>8.‘id’ and ‘void<em>’ have to be cast explicitly.<br>With ARC,To cast between ‘id’ or object types and ‘void</em>‘,you can use __bridge</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//dangerous: should be careful,since you don't know whether p have ownership or not.</span></div><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];   </div><div class="line"><span class="keyword">void</span> *p = (__bridge <span class="keyword">void</span> *)obj;</div><div class="line"><span class="keyword">id</span> o = (__bridge <span class="keyword">id</span>)p;</div><div class="line"></div><div class="line"><span class="comment">//__bridge dangling pointer example</span></div><div class="line"><span class="keyword">void</span> *p = <span class="literal">nil</span>;</div><div class="line">&#123;</div><div class="line">  <span class="keyword">id</span> obj = [<span class="built_in">NSObject</span> new];</div><div class="line">  p = (__bridge <span class="keyword">void</span> *)obj;</div><div class="line">&#125;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,(__bridge <span class="keyword">id</span>)p);<span class="comment">//错误,野指针</span></div></pre></td></tr></table></figure>
<p><code>__bridge_retained</code> 和 <code>__bridge_transfer</code> 都是用来解决<code>void *</code>的ownership的</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//__bridge_retained:__bridge_retained cast works as if the assigned variable has ownership of the object</span></div><div class="line"><span class="comment">//example 1</span></div><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"><span class="keyword">void</span> *p = (__bridge_retained <span class="keyword">void</span> *)obj;<span class="comment">//pointer p也有ownership</span></div><div class="line"></div><div class="line"><span class="comment">//example 2</span></div><div class="line"><span class="keyword">void</span> *p = <span class="number">0</span>;</div><div class="line">&#123;</div><div class="line">  <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">  p = (__bridge_retained <span class="keyword">void</span> *)obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"class=%@"</span>, [(__bridge <span class="keyword">id</span>)p <span class="keyword">class</span>]);<span class="comment">//after leave the scrope variable, p still have ownership</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//__bridge_transfer:__bridge_transfer cast will release the object just after the assignment is done.</span></div><div class="line"><span class="comment">//example 1</span></div><div class="line"><span class="keyword">id</span> obj = (__bridge_transfer <span class="keyword">id</span>)p;</div><div class="line"></div><div class="line"><span class="comment">//example 2</span></div><div class="line"><span class="keyword">void</span> *p = (__bridge_retained <span class="keyword">void</span> *)[[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"class=%@"</span>, [(__bridge <span class="keyword">id</span>)p <span class="keyword">class</span>]);</div><div class="line">(<span class="keyword">void</span>)(__bridge_transfer <span class="keyword">id</span>)p;</div></pre></td></tr></table></figure>
<h5 id="Core-Foundation"><a href="#Core-Foundation" class="headerlink" title="Core Foundation"></a>Core Foundation</h5><blockquote>
<p>iOS的系统架构分为四个层次：核心操作系统层（Core OS layer）、核心服务层（Core Services layer）、媒体层（Media layer）和可触摸层（Cocoa Touch layer）。Core Foundation框架 (CoreFoundation.framework) 是一组C语言接口，它们为iOS应用程序提供基本数据管理和服务功能。位于第二层核心服务层<br>cocoa Foundation框架位于第四层。<br><a href="https://developer.apple.com/library/content/documentation/CoreFoundation/Conceptual/CFDesignConcepts/CFDesignConcepts.html#//apple_ref/doc/uid/10000122i" target="_blank" rel="external">CoreFoundation</a></p>
</blockquote>
<p>OBJECTIVE-C OBJECT AND CORE FOUNDATION OBJECT<br>1.Core Foundation,mainly written in C;has reference counting<br>2.<a href="https://developer.apple.com/library/content/documentation/CoreFoundation/Conceptual/CFDesignConcepts/Articles/tollFreeBridgedTypes.html#//apple_ref/doc/uid/TP40010677-SW1" target="_blank" rel="external">Toll-Free Bridged Types</a>:There are a number of data types in the Core Foundation framework and the Foundation framework that can be used interchangeably. Data types that can be used interchangeably are also referred to as toll-free bridged data types</p>
<p>CFBridgingRetain function</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFTypeRef</span> <span class="built_in">CFBridgingRetain</span>(<span class="keyword">id</span> X) &#123;</div><div class="line">  <span class="keyword">return</span> (__bridge_retained <span class="built_in">CFTypeRef</span>)X;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFMutableArrayRef</span> cfObject = <span class="literal">NULL</span>;</div><div class="line">&#123;</div><div class="line">  <span class="keyword">id</span> obj = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line">  cfObject = <span class="built_in">CFBridgingRetain</span>(obj);<span class="comment">//warning...</span></div><div class="line">  <span class="comment">//cfObject =  (__bridge_retained CFMutableArrayRef)obj;//no warning</span></div><div class="line">  <span class="built_in">CFShow</span>(cfObject);</div><div class="line">  printf(<span class="string">"retain count = %d\n"</span>, <span class="built_in">CFGetRetainCount</span>(cfObject));</div><div class="line">&#125;</div><div class="line">printf(<span class="string">"retain count after the scope = %d\n"</span>, 	<span class="built_in">CFGetRetainCount</span>(cfObject)); <span class="built_in">CFRelease</span>(cfObject);</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFMutableArrayRef</span> cfObject = <span class="built_in">CFArrayCreateMutable</span>(kCFAllocatorDefault, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">printf(<span class="string">"retain count = %d\n"</span>, <span class="built_in">CFGetRetainCount</span>(cfObject));</div><div class="line"><span class="keyword">id</span> obj = <span class="built_in">CFBridgingRelease</span>(cfObject);</div><div class="line">printf(<span class="string">"retain count after the cast = %d\n"</span>,<span class="built_in">CFGetRetainCount</span>(cfObject));</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"class=%@"</span>, obj);</div></pre></td></tr></table></figure>
<h4 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h4><table>
<thead>
<tr>
<th>Property modifier</th>
<th>Ownership qualifier</th>
</tr>
</thead>
<tbody>
<tr>
<td>assign</td>
<td>__unsafe _unretained</td>
</tr>
<tr>
<td>copy</td>
<td>__strong (note: new copied object is assigned.)</td>
</tr>
<tr>
<td>retain</td>
<td>__strong</td>
</tr>
<tr>
<td>strong</td>
<td>__strong</td>
</tr>
<tr>
<td>unsafe_unretained</td>
<td>__unsafe _unretained</td>
</tr>
<tr>
<td>weak</td>
<td>__weak  </td>
</tr>
</tbody>
</table>
<h3 id="Chapter-3-ARC-implementation"><a href="#Chapter-3-ARC-implementation" class="headerlink" title="Chapter 3 ARC implementation"></a>Chapter 3 ARC implementation</h3><hr>
<h4 id="strong"><a href="#strong" class="headerlink" title="__strong"></a>__strong</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="keyword">id</span> __<span class="keyword">strong</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* pseudo code by the compiler */</span></div><div class="line"><span class="keyword">id</span> obj = objc_msgSend(<span class="built_in">NSObject</span>, <span class="keyword">@selector</span>(alloc));</div><div class="line">objc_msgSend(obj, <span class="keyword">@selector</span>(init));</div><div class="line">objc_release(obj);</div></pre></td></tr></table></figure>
<p>an object is not obtained by the alloc/new/copy/mutableCopy</p>
<p>objc_retainAutoreleasedReturnValue:  </p>
<ol>
<li><strong><code>objc_retainAutoreleasedReturnValue</code></strong> function is for performance optimization. It is inserted because the NSMutableArray class method array is not in the alloc/new/copy/mutableCopy method group. <code>The compiler</code> inserts this function every time just after the invocation of a method if the method is not in the group. As the name suggests, it <code>retains</code> an object returned from a method or function after <code>the object is added in autorelease pool</code>.  </li>
<li><strong><code>objc_retainAutoreleasedReturnValue</code></strong> function expects that an <strong><code>objc_autoreleaseReturnValue</code></strong> function has been called inside the method. Any methods, that are not in the alloc/new/copy/mutableCopy group, have to call <strong><code>objc_autoreleaseReturnValue</code></strong></li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="keyword">id</span> __<span class="keyword">strong</span> obj = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* pseudo code by the compiler */</span></div><div class="line"><span class="keyword">id</span> obj = objc_msgSend(<span class="built_in">NSMutableArray</span>, <span class="keyword">@selector</span>(array));</div><div class="line">objc_retainAutoreleasedReturnValue(obj);</div><div class="line">objc_release(obj);</div></pre></td></tr></table></figure>
<p>objc_autoreleaseReturnValue</p>
<ol>
<li><code>objc_autoreleaseReturnValue</code> adds an object to autorelease pool and returns it</li>
<li><code>objc_autoreleaseReturnValue</code> checks <code>the caller’s executable code</code> and if the code calls <code>objc_retainAutoreleasedReturnValue</code> just after calling this method: <strong>it just returns the object to the caller,So, performance will be improved.</strong><blockquote>
<p>返回值身上调用objc_autoreleaseReturnValue方法时，runtime将这个返回值object储存在TLS中，然后直接返回这个object（不调用autorelease）；同时，在外部接收这个返回值的objc_retainAutoreleasedReturnValue里，发现TLS中正好存了这个对象，那么直接返回这个object（不调用retain）。于是乎，调用方和被调方利用TLS做中转，很有默契的免去了对返回值的内存管理。<mark>即是说如果确认方法返回值一定会被其他引用持有的话,那么就不需要放进缓存池</mark></p>
</blockquote>
</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">id</span>) array &#123;</div><div class="line">  <span class="keyword">return</span> [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line">&#125;</div><div class="line"></div><div class="line">This source code is converted as follows. It calls objc_autoreleaseReturnValue function at the last.</div><div class="line"><span class="comment">/* pseudo code by the compiler */</span></div><div class="line">+ (<span class="keyword">id</span>) array</div><div class="line">&#123;</div><div class="line">  <span class="keyword">id</span> obj = objc_msgSend(<span class="built_in">NSMutableArray</span>, <span class="keyword">@selector</span>(alloc));</div><div class="line">  objc_msgSend(obj, <span class="keyword">@selector</span>(init));</div><div class="line">  <span class="keyword">return</span> objc_autoreleaseReturnValue(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170713155559.png" alt="SamuelChan/20170713155559.png"></p>
<h4 id="weak"><a href="#weak" class="headerlink" title="__weak"></a>__weak</h4><ul>
<li>Nil is assigned to any variables qualified with __weak when referencing object is discarded.</li>
<li><del> When an object is accessed through a __weak qualified variable, the object is added to the autorelease pool:</del> wrong guide</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* example */</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = obj;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* pseudo code by the compiler */</span></div><div class="line"><span class="keyword">id</span> obj1;</div><div class="line">objc_initWeak(&amp;obj1, obj); <span class="comment">//call obj1 = 0; objc_storeWeak(&amp;obj1, obj);</span></div><div class="line">objc_destroyWeak(&amp;obj1);   <span class="comment">//call objc_storeWeak(&amp;obj1, 0);</span></div></pre></td></tr></table></figure>
<blockquote>
<p><code>Hash table</code> : 我们知道，数组的最大特点就是：寻址容易，插入和删除困难；而链表正好相反，寻址困难，而插入和删除操作容易。那么如果能够结合两者的优点，做出一种寻址、插入和删除操作同样快速容易的数据结构，那该有多好。这就是哈希表创建的基本思想，而实际上哈希表也实现了这样的一个“夙愿”，哈希表就是这样一个集查找、插入和删除操作于一身的数据结构。  </p>
</blockquote>
<p><code>objc_storeWeak</code>:  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * This function stores a new value into a __weak variable. It would</div><div class="line"> * be used anywhere a __weak variable is the target of an assignment.</div><div class="line"> *</div><div class="line"> * @param location The address of the weak pointer itself</div><div class="line"> * @param newObj The new object this weak ptr should now point to</div><div class="line"> *</div><div class="line"> * @return \e newObj</div><div class="line"> */</div><div class="line"><span class="keyword">id</span> objc_storeWeak(<span class="keyword">id</span> *location, <span class="keyword">id</span> newObj)</div><div class="line"></div><div class="line"><span class="comment">//when obj = 0,the entry remove from hash table</span></div><div class="line">objc_storeWeak(&amp;obj1, obj);</div></pre></td></tr></table></figure>
<p><code>When an Object Is Discarded</code>  </p>
<ol>
<li>objc_release.</li>
<li>dealloc is called because retain count becomes zero.</li>
<li>_objc_rootDealloc.</li>
<li>object_dispose.</li>
<li>objc_destructInstance.</li>
<li>objc_clear_deallocating:<ol>
<li>From the weak table, get an entry of which the key is the object to be discarded.</li>
<li>Set nil to all the __weak ownership qualified variables in the entry.</li>
<li>Remove the entry from the table.</li>
<li>For the object to be disposed of, remove its <code>key</code> from the <strong><code>reference table</code></strong>.</li>
</ol>
</li>
</ol>
<p><code>Assigning a Newly Created Object</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="keyword">id</span> __<span class="keyword">weak</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* pseudo code by the compiler */</span></div><div class="line"><span class="keyword">id</span> obj;</div><div class="line"><span class="keyword">id</span> tmp = objc_msgSend(<span class="built_in">NSObject</span>, <span class="keyword">@selector</span>(alloc));</div><div class="line">objc_msgSend(tmp, <span class="keyword">@selector</span>(init));</div><div class="line">objc_initWeak(&amp;obj, tmp);</div><div class="line">objc_release(tmp);</div><div class="line">objc_destroyWeak(&amp;object);</div></pre></td></tr></table></figure>
<p><strong><del>Adding to autorelease pool Automatically</del></strong><br>验证汇编代码: Xcode → Debug → Debug workflow → Always show Disassembly.<br>输入下面的例子,会看到编译器插入的是release不是autorelease</p>
<p>In conclusion, this design of <strong>weak ensure that during the usage of weak pointer, its state is consistent. The <code>new</code> implmenetation of </strong>weak of <code>Apple LLVM version 8.0.0 (clang-800.0.42.1)</code> do not postpond the release to autoreleasepool, but use <code>objc_release</code> <strong>directly</strong>.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = obj;</div><div class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, obj1);</div><div class="line">&#125;</div><div class="line"><span class="comment">/* iOS5及之前编译器做法 */</span></div><div class="line"><span class="keyword">id</span> obj1;</div><div class="line">objc_initWeak(&amp;obj1, obj);</div><div class="line"><span class="keyword">id</span> tmp = objc_loadWeakRetained(&amp;obj1);</div><div class="line">objc_autorelease(tmp);<span class="comment">//错误!!!mistake</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, tmp);</div><div class="line">objc_destroyWeak(&amp;obj1);</div><div class="line"></div><div class="line"><span class="comment">/* 现在的编译器做法*/</span></div><div class="line"><span class="keyword">id</span> obj = objc_msgSend(<span class="built_in">NSObject</span>, <span class="string">"new"</span>);</div><div class="line"><span class="keyword">id</span> obj1;</div><div class="line">objc_initWeak(&amp;obj1, obj);</div><div class="line"><span class="keyword">id</span> tmp = objc_loadWeakRetained(obj1);<span class="comment">//objc_loadWeakRetained would increment the reference count to ensure that tmp is alive in the NSLog statement.</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, obj1);</div><div class="line">objc_release(tmp);</div><div class="line">objc_destroyWeak(&amp;obj1);</div><div class="line">objc_storeStrong(&amp;obj, <span class="number">0</span>);<span class="comment">//release</span></div></pre></td></tr></table></figure>
<p><a href="https://lists.apple.com/archives/objc-language/2012/Aug/msg00027.htm‌​l" target="_blank" rel="external">苹果list</a><br><a href="https://stackoverflow.com/questions/40993809/why-weak-object-will-be-added-to-autorelease-pool/41008619#41008619" target="_blank" rel="external">参考资料1</a><br><a href="https://stackoverflow.com/questions/34083137/objective-c-weak-object-is-registered-in-autoreleasepool-automatically?rq=1" target="_blank" rel="external">参考资料2</a></p>
<h4 id="autoreleasing"><a href="#autoreleasing" class="headerlink" title="__autoreleasing"></a>__autoreleasing</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">  <span class="keyword">id</span> __autoreleasing obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* pseudo code by the compiler */</span></div><div class="line"><span class="keyword">id</span> pool = objc_autoreleasePoolPush();</div><div class="line"><span class="keyword">id</span> obj = objc_msgSend(<span class="built_in">NSObject</span>, <span class="keyword">@selector</span>(alloc));</div><div class="line">objc_msgSend(obj, <span class="keyword">@selector</span>(init));  </div><div class="line">objc_autorelease(obj);    <span class="comment">//放进自动释放池</span></div><div class="line">objc_autoreleasePoolPop(pool);</div><div class="line"></div><div class="line"><span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">  <span class="keyword">id</span> __autoreleasing obj = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* pseudo code by the compiler */</span></div><div class="line"><span class="keyword">id</span> pool = objc_autoreleasePoolPush();</div><div class="line"><span class="keyword">id</span> obj = objc_msgSend(<span class="built_in">NSMutableArray</span>, <span class="keyword">@selector</span>(array));</div><div class="line">objc_retainAutoreleasedReturnValue(obj);</div><div class="line">objc_autorelease(obj);</div><div class="line">objc_autoreleasePoolPop(pool);</div></pre></td></tr></table></figure>
<h4 id="Reference-Count"><a href="#Reference-Count" class="headerlink" title="Reference Count"></a>Reference Count</h4><p><code>uintptr_t _objc_rootRetainCount(id obj)</code>:don’t return reliable value all the time</p>
<h3 id="NSObject开源release-retain-dealloc内存管理的实现"><a href="#NSObject开源release-retain-dealloc内存管理的实现" class="headerlink" title="NSObject开源release,retain,dealloc内存管理的实现"></a>NSObject开源release,retain,dealloc内存管理的实现</h3><hr>
<blockquote>
<ol>
<li>本书本之前讨论的内存管理是基于GNUStep或者是CFFoundation里面的内存管理部分.现在NSObject已经开源了</li>
<li><a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external">objc4-709</a></li>
</ol>
</blockquote>
<h4 id="引用计数的储存"><a href="#引用计数的储存" class="headerlink" title="引用计数的储存"></a>引用计数的储存</h4><p>有些对象如果支持使用<code>TaggedPointer</code>，苹果会直接将其指针值作为引用计数返回；否则 Runtime 会使用一张<code>散列表</code>来管理引用计数。</p>
<h4 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h4><h5 id="1-TaggedPointer-判断当前对象是否在使用-TaggedPointer-是看标志位是否为-1-id的isTaggedPointer-方法经常会在操作引用计数时用到，因为这决定了存储引用计数的策略。"><a href="#1-TaggedPointer-判断当前对象是否在使用-TaggedPointer-是看标志位是否为-1-id的isTaggedPointer-方法经常会在操作引用计数时用到，因为这决定了存储引用计数的策略。" class="headerlink" title="1.TaggedPointer: 判断当前对象是否在使用 TaggedPointer 是看标志位是否为 1;id的isTaggedPointer()方法经常会在操作引用计数时用到，因为这决定了存储引用计数的策略。"></a>1.TaggedPointer: 判断当前对象是否在使用 TaggedPointer 是看标志位是否为 1;id的isTaggedPointer()方法经常会在操作引用计数时用到，因为这决定了存储引用计数的策略。</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_MSB_TAGGED_POINTERS</span></div><div class="line"><span class="meta">#   <span class="meta-keyword">define</span> TAG_MASK (1ULL&lt;&lt;63)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#   <span class="meta-keyword">define</span> TAG_MASK 1</span></div><div class="line"></div><div class="line"><span class="keyword">inline</span> <span class="keyword">bool</span></div><div class="line">objc_object::isTaggedPointer()</div><div class="line">&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_TAGGED_POINTERS</span></div><div class="line">    <span class="keyword">return</span> ((<span class="keyword">uintptr_t</span>)<span class="keyword">this</span> &amp; TAG_MASK);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-散列表"><a href="#2-散列表" class="headerlink" title="2.散列表"></a>2.散列表</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SideTable</span> &#123;</span></div><div class="line">    <span class="comment">// 保证原子操作的自旋锁</span></div><div class="line">    <span class="keyword">spinlock_t</span> slock;</div><div class="line">    <span class="comment">// 引用计数的 hash 表</span></div><div class="line">    RefcountMap refcnts;</div><div class="line">    <span class="comment">// weak 引用全局 hash 表</span></div><div class="line">    <span class="keyword">weak_table_t</span> weak_table;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">SideTable 结构体重定了几个非常重要的变量。</div><div class="line"><span class="comment">// The order of these bits is important.</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_WEAKLY_REFERENCED (1UL&lt;&lt;0)    </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_DEALLOCATING      (1UL&lt;&lt;1)  <span class="comment">// MSB-ward of weak bit</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_RC_ONE            (1UL&lt;&lt;2)  <span class="comment">// MSB-ward of deallocating bit</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_RC_PINNED         (1UL&lt;&lt;(WORD_BITS-1))<span class="comment">//最高位字节为0</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_RC_SHIFT 2</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_FLAG_MASK (SIDE_TABLE_RC_ONE-1)</span></div></pre></td></tr></table></figure>
<p><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170717173215.png" alt="SamuelChan/20170717173215.png"></p>
<h5 id="3-retainCount"><a href="#3-retainCount" class="headerlink" title="3.retainCount"></a>3.retainCount</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSUInteger</span>)retainCount &#123;</div><div class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>)<span class="keyword">self</span>)-&gt;rootRetainCount();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">inline</span> uintptr_t</div><div class="line">objc_object::rootRetainCount()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (uintptr_t)<span class="keyword">this</span>;</div><div class="line">    <span class="keyword">return</span> sidetable_retainCount();</div><div class="line">&#125;</div><div class="line"></div><div class="line">uintptr_t</div><div class="line">objc_object::sidetable_retainCount()</div><div class="line">&#123;</div><div class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</div><div class="line">    size_t refcnt_result = <span class="number">1</span>;</div><div class="line"></div><div class="line">    table.lock();</div><div class="line">    RefcountMap::iterator it = table.refcnts.find(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">if</span> (it != table.refcnts.end()) &#123;</div><div class="line">        <span class="comment">// this is valid for SIDE_TABLE_RC_PINNED too</span></div><div class="line">        refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;<span class="comment">//右移两位</span></div><div class="line">    &#125;</div><div class="line">    table.unlock();</div><div class="line">    <span class="keyword">return</span> refcnt_result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="4-retain"><a href="#4-retain" class="headerlink" title="4.retain"></a>4.retain</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)<span class="keyword">retain</span> &#123;</div><div class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>)<span class="keyword">self</span>)-&gt;rootRetain();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Base retain implementation, ignoring overrides.</span></div><div class="line"><span class="comment">// This does not check isa.fast_rr; if there is an RR override then</span></div><div class="line"><span class="comment">// it was already called and it chose to call [super retain].</span></div><div class="line"><span class="keyword">inline</span> <span class="keyword">id</span></div><div class="line">objc_object::rootRetain()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</div><div class="line">    <span class="keyword">return</span> sidetable_retain();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">id</span></div><div class="line">objc_object::sidetable_retain()</div><div class="line">&#123;</div><div class="line"><span class="meta">#if SUPPORT_NONPOINTER_ISA</span></div><div class="line">    assert(!isa.nonpointer);</div><div class="line"><span class="meta">#endif</span></div><div class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</div><div class="line"></div><div class="line">    table.lock();</div><div class="line">    size_t&amp; refcntStorage = table.refcnts[<span class="keyword">this</span>];</div><div class="line">    <span class="keyword">if</span> (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123;</div><div class="line">    	<span class="comment">//相当于+(1 &lt;&lt; 2)</span></div><div class="line">        refcntStorage += SIDE_TABLE_RC_ONE;</div><div class="line">    &#125;</div><div class="line">    table.unlock();</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="5-release"><a href="#5-release" class="headerlink" title="5. release"></a>5. release</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">oneway</span> <span class="keyword">void</span>)release &#123;</div><div class="line">    ((<span class="keyword">id</span>)<span class="keyword">self</span>)-&gt;rootRelease();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">inline</span> <span class="keyword">bool</span></div><div class="line">objc_object::rootRelease()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">return</span> sidetable_release(<span class="literal">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// rdar://20206767</span></div><div class="line"><span class="comment">// return uintptr_t instead of bool so that the various raw-isa</span></div><div class="line"><span class="comment">// -release paths all return zero in eax</span></div><div class="line">uintptr_t</div><div class="line">objc_object::sidetable_release(<span class="keyword">bool</span> performDealloc)</div><div class="line">&#123;</div><div class="line"><span class="meta">#if SUPPORT_NONPOINTER_ISA</span></div><div class="line">    assert(!isa.nonpointer);</div><div class="line"><span class="meta">#endif</span></div><div class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</div><div class="line">    <span class="keyword">bool</span> do_dealloc = <span class="literal">false</span>;</div><div class="line">    table.lock();</div><div class="line">    RefcountMap::iterator it = table.refcnts.find(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">if</span> (it == table.refcnts.end()) &#123;</div><div class="line">        do_dealloc = <span class="literal">true</span>;</div><div class="line">        table.refcnts[<span class="keyword">this</span>] = SIDE_TABLE_DEALLOCATING;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it-&gt;second &lt; SIDE_TABLE_DEALLOCATING) &#123;</div><div class="line">        <span class="comment">// 判断引用计数是否为0,如果小于SIDE_TABLE_DEALLOCATING,只有00000001或者00000000,两种情况下,引用计数都为0,所以需要将do_dealloc置为0</span></div><div class="line">        <span class="comment">// SIDE_TABLE_WEAKLY_REFERENCED may be set. Don't change it.</span></div><div class="line">        do_dealloc = <span class="literal">true</span>;</div><div class="line">        it-&gt;second |= SIDE_TABLE_DEALLOCATING;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (! (it-&gt;second &amp; SIDE_TABLE_RC_PINNED)) &#123;</div><div class="line">    	 <span class="comment">// 如果符合这个条件,即:引用计数没有溢出(最高位为0),do_dealloc为0,weak_reference为0)</span></div><div class="line">        it-&gt;second -= SIDE_TABLE_RC_ONE;</div><div class="line">    &#125;</div><div class="line">    table.unlock();</div><div class="line">    <span class="keyword">if</span> (do_dealloc  &amp;&amp;  performDealloc) &#123;</div><div class="line">        ((<span class="keyword">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, SEL_dealloc);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> do_dealloc;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="6-alloc"><a href="#6-alloc" class="headerlink" title="6. alloc"></a>6. alloc</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+alloc</div><div class="line">+allocWithZone:</div><div class="line">class_createInstance</div><div class="line">calloc</div></pre></td></tr></table></figure>
<h5 id="7-dealloc"><a href="#7-dealloc" class="headerlink" title="7.dealloc"></a>7.dealloc</h5><ol>
<li>objc_release.</li>
<li>dealloc is called because retain count becomes zero.</li>
<li>_objc_rootDealloc.</li>
<li>object_dispose.</li>
<li>objc_destructInstance</li>
<li>objc_clear_deallocating:<ol>
<li>From the weak table, get an entry of which the key is the object to be discarded.</li>
<li>Set nil to all the __weak ownership qualified variables in the entry.</li>
<li>Remove the entry from the table.</li>
<li>For the object to be disposed of, remove its <code>key</code> from the <strong><code>reference table</code></strong></li>
</ol>
</li>
</ol>
<h5 id="8-autorelease"><a href="#8-autorelease" class="headerlink" title="8.autorelease"></a>8.autorelease</h5><p>参考资料:<br><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="external">黑幕背后的Autorelease</a></p>
<ul>
<li>Autorelease对象什么时候释放？<br>在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的runloop迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop</li>
<li>AutoreleasePoolPage:是一个C++实现的类,<br><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170717194057.png" alt="SamuelChan/20170717194057.png"><ul>
<li>AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage以<a href="http://www.cnblogs.com/skywang12345/p/3561803.html#a31" target="_blank" rel="external">双向链表</a>的形式组合而成（分别对应结构中的parent指针和child指针）</li>
<li>AutoreleasePool是按线程一一对应的（结构中的thread指针指向当前线程）</li>
<li>AutoreleasePoolPage每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地址</li>
<li>上面的id *next指针作为游标指向栈顶最新add进来的autorelease对象的下一个位置</li>
<li>一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入</li>
</ul>
</li>
<li>AutoreleasePoolPage快要满的时候:也就是next指针马上指向栈顶，这时就要执行上面说的操作，建立下一页page对象，与这一页链表连接完成后，新page的next指针被初始化在栈底（begin的位置），然后继续向栈顶添加新对象。</li>
</ul>
<p><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170717194341.png" alt="SamuelChan/20170717194341.png"></p>
<ul>
<li>释放时刻:根据哨兵位置进行pop释放池,每当进行一次objc_autoreleasePoolPush调用时，runtime向当前的AutoreleasePoolPage中add进一个哨兵对象，值为0（也就是个nil）<br><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170717194612.png" alt="SamuelChan/20170717194612.png"></li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> *context = objc_autoreleasePoolPush();</div><div class="line"><span class="comment">// &#123;&#125;中的代码</span></div><div class="line">objc_autoreleasePoolPop(context);</div></pre></td></tr></table></figure>
<ul>
<li>使用容器的block版本的枚举器时，内部会自动添加一个AutoreleasePool,普通for/for in中没有  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> [array enumerateObjectsUsingBlock:^(<span class="keyword">id</span> obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop) &#123;</div><div class="line">    <span class="comment">// 这里被一个局部@autoreleasepool包围着</span></div><div class="line">&#125;];</div></pre></td></tr></table></figure>
</li>
</ul>
<p>参考资料:<br>1.<a href="http://yulingtianxia.com/blog/2015/12/06/The-Principle-of-Refenrence-Counting/" target="_blank" rel="external">Objective-C 引用计数原理</a>,部分地方最新的obj4版本已经改了<br>2.<a href="http://zhoulingyu.com/2017/02/15/Advanced-iOS-Study-objc-Memory-2/" target="_blank" rel="external">iOS进阶——iOS（Objective-C）内存管理·二
</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Problems:  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个非alloc/new/copy/muteCopy返回对象的方法应该由谁管理内存?  &lt;/li&gt;
&lt;li&gt;AutoReleasePool也需要进行内存管理吗?如果要,谁来管理?&lt;/li&gt;
&lt;/ol
    
    </summary>
    
      <category term="Objective-C" scheme="http://yoursite.com/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>禅与Objective-C编程艺术读书笔记</title>
    <link href="http://yoursite.com/2017/06/30/%E7%A6%85%E4%B8%8EObjective-C%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/"/>
    <id>http://yoursite.com/2017/06/30/禅与Objective-C编程艺术/</id>
    <published>2017-06-30T03:06:52.000Z</published>
    <updated>2017-07-19T12:49:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="禅与Objective-C编程艺术读书笔记"><a href="#禅与Objective-C编程艺术读书笔记" class="headerlink" title="禅与Objective-C编程艺术读书笔记"></a>禅与Objective-C编程艺术读书笔记</h3><h4 id="1-条件语句"><a href="#1-条件语句" class="headerlink" title="1.条件语句"></a>1.条件语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">1. if (!error) &#123;</div><div class="line">	return success;&#125;</div><div class="line"></div><div class="line">2. 不使用尤达表达式</div><div class="line">if ([myValue isEqual:@42]) &#123; ...</div><div class="line"></div><div class="line">3. nil跟BOOL检查: nil解释为NO YES解释为1</div><div class="line">if (someObject) &#123; ...</div><div class="line">if (![someObject boolValue]) &#123; ...</div><div class="line">if (!someObject) &#123; ...</div><div class="line">Not Preferred:</div><div class="line">if (someObject == YES) &#123; ... // Wrong</div><div class="line">if (myRawValue == YES) &#123; ... // Never do this.</div><div class="line">if ([someObject boolValue] == NO) &#123; //Wrong</div><div class="line"></div><div class="line">4. Golden Path: 不要嵌套if,减少复杂度</div><div class="line">- (void)someMethod &#123;</div><div class="line">  if (![someOther boolValue]) &#123;</div><div class="line">      return;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  //Do something important</div><div class="line">&#125;</div><div class="line"></div><div class="line">5.复杂的条件表达式:如果if的条件判断很复杂,建议先赋值给变量名清晰的BOOL变量</div><div class="line">BOOL nameContainsSwift = [sessionName containsString:@&quot;Swift&quot;];  </div><div class="line">BOOL isCurrentYear = [sessionDateCompontents year] == 2014;</div><div class="line">BOOL isSwiftSession = nameContainsSwift &amp;&amp; isCurrentYear;if (isSwiftSession) &#123;// Do something very cool&#125;</div><div class="line"></div><div class="line">6. 三元运算符:优先级从右到左</div><div class="line">result = object ? : [self createObject];</div><div class="line"></div><div class="line">7. case: 单行括号不强制,执行直到break</div><div class="line">8. 位移枚举</div><div class="line">typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) &#123;    二进制值    十进制</div><div class="line">    UIViewAutoresizingNone                 = 0,         0000 0000  0</div><div class="line">    UIViewAutoresizingFlexibleLeftMargin   = 1 &lt;&lt; 0,    0000 0001  1</div><div class="line">    UIViewAutoresizingFlexibleWidth        = 1 &lt;&lt; 1,    0000 0010  2</div><div class="line">    UIViewAutoresizingFlexibleRightMargin  = 1 &lt;&lt; 2,    0000 0100  4</div><div class="line">    UIViewAutoresizingFlexibleTopMargin    = 1 &lt;&lt; 3,    0000 1000  8</div><div class="line">    UIViewAutoresizingFlexibleHeight       = 1 &lt;&lt; 4,    0001 0000  16</div><div class="line">    UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5     0010 0000  32</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//模拟实现</div><div class="line">-(void)todo:(UIViewAutoresizing)type&#123;</div><div class="line">    if (type==0) &#123;</div><div class="line">        NSLog(@&quot;UIViewAutoresizingNone&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    if (type &amp; UIViewAutoresizingFlexibleLeftMargin) &#123;</div><div class="line">        NSLog(@&quot;UIViewAutoresizingFlexibleLeftMargin&quot;);</div><div class="line">    &#125;</div><div class="line">    if (type &amp; UIViewAutoresizingFlexibleWidth) &#123;</div><div class="line">        NSLog(@&quot;UIViewAutoresizingFlexibleWidth&quot;);</div><div class="line">    &#125;</div><div class="line">    if (type &amp; UIViewAutoresizingFlexibleRightMargin) &#123;</div><div class="line">        NSLog(@&quot;UIViewAutoresizingFlexibleRightMargin&quot;);</div><div class="line">    &#125;</div><div class="line">    if (type &amp; UIViewAutoresizingFlexibleTopMargin) &#123;</div><div class="line">        NSLog(@&quot;UIViewAutoresizingFlexibleTopMargin&quot;);</div><div class="line">    &#125;</div><div class="line">    if (type &amp; UIViewAutoresizingFlexibleHeight) &#123;</div><div class="line">        NSLog(@&quot;UIViewAutoresizingFlexibleHeight&quot;);</div><div class="line">    &#125;</div><div class="line">    if (type &amp; UIViewAutoresizingFlexibleBottomMargin) &#123;</div><div class="line">        NSLog(@&quot;UIViewAutoresizingFlexibleBottomMargin&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line"></div><div class="line">    [self todo:UIViewAutoresizingFlexibleLeftMargin|UIViewAutoresizingFlexibleRightMargin|UIViewAutoresizingFlexibleHeight];</div><div class="line">&#125;</div><div class="line">结果输出</div><div class="line">UIViewAutoresizingFlexibleLeftMargin</div><div class="line">UIViewAutoresizingFlexibleRightMargin</div><div class="line">UIViewAutoresizingFlexibleHeight</div></pre></td></tr></table></figure>
<h4 id="2-命名规范"><a href="#2-命名规范" class="headerlink" title="2.命名规范"></a>2.命名规范</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">1.变量: 驼峰命名,类名开头</div><div class="line">	static const NSTimeInterval ZOCSignInViewControllerFadeOutAnimationDuration = 0.4;</div><div class="line"></div><div class="line">	/*static NSString const * kUserName = static NSString const (* kUserName )</div><div class="line">     kUserName为指针, *kUserName是指针指向的地址的内容</div><div class="line">     static NSString const * kUserName代表常量指针:指针必须指向任意一个常量</div><div class="line">     */</div><div class="line">    static NSString const *kUserName = @&quot;kUserName&quot;;</div><div class="line">    NSLog(@&quot;kUserName = %p,*kUserName = %p&quot;,&amp;kUserName,&amp;(*kUserName));</div><div class="line">    kUserName = @&quot;OtherName&quot;;</div><div class="line">    NSLog(@&quot;kUserName = %p,*kUserName = %p&quot;,&amp;kUserName,&amp;(*kUserName));</div><div class="line"></div><div class="line">    /*static NSString *const kUserName = static NSString  * const (kUserName)</div><div class="line">     kUserName为指针常量</div><div class="line">     */</div><div class="line">    static NSString *const name = @&quot;name&quot;;</div><div class="line">	//name = @&quot;kfkfkfk&quot;;//错误</div><div class="line"></div><div class="line">2.方法</div><div class="line">  类(-/+)间应该以空格间隔,方法段之间也应该用空格隔开</div><div class="line">  尽可能少用and作为方法段名</div><div class="line">  - (instancetype)initWith:(int)width and:(int)height; // Never do this.</div><div class="line">  推荐一下写法:</div><div class="line">  - (void)setExampleText:(NSString *)text image:(UIImage *)image;  - (void)sendAction:(SEL)aSelector to:(id)anObject forAllCells:(BOOL)flag; - (id)viewWithTag:(NSInteger)tag;  - (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height;</div></pre></td></tr></table></figure>
<h4 id="3-类"><a href="#3-类" class="headerlink" title="3.类"></a>3.类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">1.类名: 头三个字母最好是大写,避免与头两个字母是大写的苹果官方类冲突</div><div class="line">2.initializer</div><div class="line">	alloc 负责创建对象，这个过程包括分配足够的内存来保存对象，写入 isa 指针，初始化引用计数，以及重置所有实例变量。</div><div class="line">	init 负责初始化对象，这意味着使对象处于可用状态。这通常意味着为对象的实例变量赋予合理有用的值。</div><div class="line">3.designated initializer secondary initializer:一个直接,多个间接.</div><div class="line">4.单例:</div><div class="line">	+ (instancetype)sharedInstance &#123;		static id sharedInstance = nil;</div><div class="line">		static dispatch_once_t onceToken = 0;   </div><div class="line">		dispatch_once(&amp;onceToken, ^&#123;			sharedInstance = [[self alloc] init];</div><div class="line">		&#125;);		return sharedInstance;</div><div class="line">	&#125;</div><div class="line">5.属性:</div><div class="line">@property (assign, getter=isEditable) BOOL editable;</div><div class="line"></div><div class="line">6.方法:</div><div class="line">参数断言:判断某个参数是否满足条件,使用NSParameterAssert(),debug默认开启,release默认关闭</div><div class="line">    NSInteger a = 10;</div><div class="line">    NSParameterAssert(a&gt; 1 &amp;&amp; a &gt; 10);</div><div class="line">自定义私有方法:不要以_开头,_是苹果保留的,不能冒重载私有方法的险</div><div class="line"></div><div class="line">7.分类:在分类方法名加上前缀,在编写静态库时,一定要注意加上前缀,防止与使用者冲突;发生冲突的时候将会以加载顺序最后的分类方法生效</div><div class="line">@interface NSDate (ZOCTimeExtensions)</div><div class="line">- (NSString *)zoc_timeAgoShort;</div><div class="line"></div><div class="line">8.通知:</div><div class="line">// Foo.hUIKIT_EXTERN NSString * const ZOCFooDidBecomeBarNotification</div><div class="line">// Foo.mNSString * const ZOCFooDidBecomeBarNotification = @&quot;ZOCFooDidBecomeBarNotification&quot;;</div><div class="line">@end</div><div class="line"></div><div class="line">9.代理优化:从面向对象到面向协议,只需要遵守ZOCFeedParserProtocol.h的对象</div><div class="line">- (instancetype)initWithFeedParser:(id&lt;ZOCFeedParserProtocol&gt;)feedParser;</div><div class="line"></div><div class="line">@protocol ZOCFeedParserDelegate;</div><div class="line"></div><div class="line">@protocol ZOCFeedParserProtocol &lt;NSObject&gt;</div><div class="line">@property (nonatomic, weak) id &lt;ZOCFeedParserDelegate&gt; delegate;</div><div class="line">@property (nonatomic, strong) NSURL *url;</div><div class="line"></div><div class="line">- (BOOL)start;</div><div class="line">- (void)stop;</div><div class="line">@end</div><div class="line"></div><div class="line">@protocol ZOCFeedParserDelegate &lt;NSObject&gt;</div><div class="line">@optional</div><div class="line">- (void)feedParserDidStart:(id&lt;ZOCFeedParserProtocol&gt;)parser;</div><div class="line">- (void)feedParser:(id&lt;ZOCFeedParserProtocol&gt;)parser didParseFeedInfo:(id)info;</div><div class="line">- (void)feedParser:(id&lt;ZOCFeedParserProtocol&gt;)parser didParseFeedItem:(id)item;</div><div class="line">- (void)feedParserDidFinish:(id&lt;ZOCFeedParserProtocol&gt;)parser;</div><div class="line">- (void)feedParser:(id&lt;ZOCFeedParserProtocol&gt;)parser didFailWithError:(NSError *)error;</div></pre></td></tr></table></figure>
<p><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170630192229.png" alt="SamuelChan/20170630192229.png"></p>
<h4 id="4-美化代码"><a href="#4-美化代码" class="headerlink" title="4.美化代码"></a>4.美化代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">1.方法的大括号和其他(if/else/switch/while)在同一行开始,新起一行结束</div><div class="line">2.应该总是让冒号对齐。有一些方法签名可能超过三个冒号，用冒号对齐可以让代码更具有可读性。即使有代码块存在，也应该用冒号对齐方法。</div><div class="line">	[UIView animateWithDuration:1.0</div><div class="line">             	 	 animations:^&#123;</div><div class="line">                  	   // something</div><div class="line">               	  	&#125;</div><div class="line">                 	 completion:^(BOOL finished) &#123;</div><div class="line">                       // something</div><div class="line">                 	&#125;];</div></pre></td></tr></table></figure>
<h4 id="5-代码组织"><a href="#5-代码组织" class="headerlink" title="5.代码组织"></a>5.代码组织</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">1.利用代码块:代码块如果在闭合的圆括号中的话,会返回最后的值</div><div class="line">NSURL *url = (&#123;	NSString *urlString = [NSString stringWithFormat:@&quot;%@/%@&quot;, baseURLString, endpoint];</div><div class="line">	[NSURL URLWithString:urlString];&#125;);</div><div class="line">2.#pragma mark - 是一个在类内部组织代码并且帮助你分组方法实现的好办法</div><div class="line"></div><div class="line">3.当你调用NSSelectorFromString的时候,编译器不确定它是否会造成内存泄露,会报警告:performSelector may cause a leak because its selector is unknown. 如果确定不会泄露,那么就加上下面的代码忽略警告</div><div class="line">	#pragma clang diagnostic push	#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;      [self performSelector:NSSelectorFromString(@&quot;testtest&quot;) withObject:@&quot;&quot;];</div><div class="line">	#pragma clang diagnostic pop</div><div class="line"></div><div class="line">4.人为明确编译器的警告和错误:</div><div class="line">#error Whoa, buddy, you need to check for zero here!</div><div class="line">#warning Dude, don&apos;t compare floating point numbers like this!</div><div class="line"></div><div class="line">5.注释相关:</div><div class="line">没有参数的方法使用&quot;//&quot;进行注释</div><div class="line">只在.h中写注释</div></pre></td></tr></table></figure>
<h4 id="6-对象之间的通讯"><a href="#6-对象之间的通讯" class="headerlink" title="6.对象之间的通讯"></a>6.对象之间的通讯</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">1. block</div><div class="line">(1)把提供需要的数据和错误信息整合到一个单独的block中,比分别提供成功失败的要好</div><div class="line">(NSURLSession/NSURLConnection)</div><div class="line"></div><div class="line">- (void)downloadObjectsAtPath:(NSString *)pathcompletion:(void(^)(NSArray *objects, NSError *error))completion;</div><div class="line"></div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)GET:(NSString *)URLString</div><div class="line">                            parameters:(nullable id)parameters</div><div class="line">                              progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgress</div><div class="line">                               success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                               failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</div><div class="line"></div><div class="line">(2)block在栈上创建</div><div class="line"></div><div class="line">(3)可复制到堆上: block作为属性,MRC下需要使用copy来将它拷贝到堆上;</div><div class="line">            ARC下只是为了一致性将block属性声明为copy,编译器会自动将block拷贝到堆上</div><div class="line"></div><div class="line">(4)block会捕获栈上的变量(指针),将其复制为自己私有的const变量</div><div class="line">(5)如果要修改block中的变量(指针),那么变量和指针必须使用__block关键字声明:__block变量的栈变量被复制到堆上,复制完成后,block将会引用的是这份已经在堆上的副本</div><div class="line">(6)使用:</div><div class="line"> - 直接在 block 里面使用关键词 self:  只能在 block 不是作为一个 property 的时候使用，否则会导致 retain cycle。</div><div class="line"> - 在 block 外定义一个 __weak 的 引用到 self，并且在 block 里面使用这个弱引用: 当 block 被声明为一个 property 的时候使用。</div><div class="line"> - 在 block 外定义一个 __weak 的 引用到 self，并在在 block 内部通过这个弱引用定义一个 __strong 的引用。: 和并发执行有关。当涉及异步的服务的时候，block 可以在之后被执行，并且不会发生关于 self 是否存在的问题,保证在block执行期间引用的对象不被置为nil,但是也可能存在block执行时对象已经为空</div><div class="line"></div><div class="line">2.DataSource和delegate   ---  委托者 vs 代理者</div><div class="line">(1)代理方法的第一个参数必须是调用代理者:否则没有办法区分不同的委托者</div><div class="line">(2)	@required @optional 默认的代理方法为@required</div><div class="line">	if ([self.delegate 	respondsToSelector:@selector(signUpViewControllerDidPressSignUpButton:	)]) &#123;</div><div class="line">		[self.delegate signUpViewControllerDidPressSignUpButton:self];	&#125;</div><div class="line">(3)继承代理实现:</div><div class="line">继承关系:UIViewControllerB &lt; UIViewControllerA &lt; UIViewController</div><div class="line">UIViewControllerA.h遵守UITableViewDelegate</div><div class="line">UIViewControllerB.m想要重写UITableViewDelegate</div><div class="line">- 如果代理方法是必须实现的话, UIViewControllerB可以直接call [super ...]</div><div class="line">- 如果是@optional的代理方法, UIViewControllerB必须检查UIViewControllerA是否有实现	- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123;		CGFloat retVal = 0;		if ([[UIViewControllerA class] instancesRespondToSelector:@selector(tableView:heightForRowAtIndexPath:)]) &#123;		retVal = [super tableView:self.tableView heightForRowAtIndexPath:indexPath];</div><div class="line">		&#125;		return retVal + 10.0f;</div><div class="line">	&#125;</div><div class="line">参考资料:http://devetc.org/code/2014/03/02/subclassing-delegates.html#fn:_cmd-arg(在相同方法中@selector(xxx) == _cmd)</div></pre></td></tr></table></figure>
<h4 id="7-多重代理"><a href="#7-多重代理" class="headerlink" title="7.多重代理"></a>7.多重代理</h4><ol>
<li>多个代理对象由一个proxy类来管理,proxy作为委托者的delegate</li>
<li>proxy并没有实现代理回调,所以这里需要使用到运行时的相关方法<br><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170704113634.png" alt="SamuelChan/20170704113634.png"></li>
<li>相关代码  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">(1)设置proxy代理</div><div class="line">    _multipleDelegate = [MultipleDelegate new];</div><div class="line">    //添加要处理delegate方法的对象</div><div class="line">    NSArray *array = @[self, [ScrollDelegate new]];</div><div class="line">    _multipleDelegate.allDelegates = array;</div><div class="line">    self.scrollView.delegate = (id)_multipleDelegate;</div><div class="line">(2)防止强引用</div><div class="line">- (void)setDelegateTargets:(NSArray *)delegateTargets&#123;</div><div class="line">    self.weakRefTargets = [NSPointerArray weakObjectsPointerArray];</div><div class="line">    for (id delegate in delegateTargets) &#123;</div><div class="line">        [self.weakRefTargets addPointer:(__bridge void *)delegate];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">(3)分发代理方法:</div><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123;</div><div class="line">    NSMethodSignature *signature = [super methodSignatureForSelector:aSelector];</div><div class="line">    if (!signature) &#123;</div><div class="line">        for (id target in self.allDelegates) &#123;</div><div class="line">            if ((signature = [target methodSignatureForSelector:aSelector])) &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return signature;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation&#123;</div><div class="line">    for (id target in self.allDelegates) &#123;</div><div class="line">        if ([target respondsToSelector:anInvocation.selector]) &#123;</div><div class="line">            [anInvocation invokeWithTarget:target];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">由于我们调用delegate的方法时，一般会先调用[delegate responseToSelector]方法，所以，我们还需要实现这个方法：</div><div class="line">- (BOOL)respondsToSelector:(SEL)aSelector&#123;</div><div class="line">    if ([super respondsToSelector:aSelector]) &#123;</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    for (id target in self.allDelegates) &#123;</div><div class="line">        if ([target respondsToSelector:aSelector]) &#123;</div><div class="line">            return YES;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return NO;</div><div class="line">&#125;  </div><div class="line">@end</div></pre></td></tr></table></figure>
<p><a href="http://www.cocoachina.com/ios/20151208/14595.html" target="_blank" rel="external">多个代理资料</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;禅与Objective-C编程艺术读书笔记&quot;&gt;&lt;a href=&quot;#禅与Objective-C编程艺术读书笔记&quot; class=&quot;headerlink&quot; title=&quot;禅与Objective-C编程艺术读书笔记&quot;&gt;&lt;/a&gt;禅与Objective-C编程艺术读书笔记&lt;/
    
    </summary>
    
      <category term="Objective-C" scheme="http://yoursite.com/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>应用评价</title>
    <link href="http://yoursite.com/2017/06/15/%E5%BA%94%E7%94%A8%E8%AF%84%E4%BB%B7/"/>
    <id>http://yoursite.com/2017/06/15/应用评价/</id>
    <published>2017-06-15T13:25:52.000Z</published>
    <updated>2017-07-19T12:49:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="应用评价"><a href="#应用评价" class="headerlink" title="应用评价"></a>应用评价</h2><h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if (!产品经理遵守review GuideLines) &#123;</div><div class="line">    //Do whatever he want</div><div class="line">&#125;else &#123;</div><div class="line">    if (iOSVersion &gt;= 10.3) &#123;</div><div class="line">        //使用SKStoreReviewController的requestReview方法</div><div class="line">    &#125;else &#123;</div><div class="line">        //1.怎么展示:openUrl SKStoreProductViewController</div><div class="line">        //2.什么时候展示: iRate,服务器控制</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h3><ol>
<li>每个应用在App store上面都会有用户的评价和评分  </li>
<li>评价和评分越高的应用将会被优先展示,排名提高.所以才有那么多人刷榜,尤其是游戏,但是从iOS11开始的App store将只会展示每个分类下前三个应用  </li>
<li>在2017.6苹果更新了Review GuideLines,强制要求开发者使用iOS 10.3引入的api:<code>SKStoreReviewController的requestReview方法</code>, 也就是说iOS 10.3之后的版本弹出的框应用使用这个api,一旦发现会被拒绝,<strong>可是很明显审核的时候是很难发现的</strong>.</li>
</ol>
<blockquote>
<p>1.1.7 App Store Reviews:<br>  App Store customer reviews can be an integral part of the app experience, so you should treat customers with respect when responding to their comments. Keep your responses targeted to the user’s comments and do not include personal information, spam, or marketing in your response.<br>Use the provided API to prompt users to review your app; this functionality allows customers to provide an App Store rating and review without the inconvenience of leaving your app, and we will disallow custom review prompts.</p>
</blockquote>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="iOS-10-3之前实现应用内评价的方法"><a href="#iOS-10-3之前实现应用内评价的方法" class="headerlink" title="iOS 10.3之前实现应用内评价的方法"></a><code>iOS 10.3之前</code>实现应用内评价的方法</h4><p>怎么展示:  </p>
<ol>
<li>现在应用最多的做法:弹出一个UIAlertView,三个button,但是其中两个都是会跳到app store的  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">	UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;程序猿奋力出新版&quot; message:@&quot;打滚儿求好评&quot; delegate:self cancelButtonTitle:@&quot;残忍拒绝&quot; otherButtonTitles:@&quot;好评(跳App store)&quot;,@&quot;吐槽(跳App store)&quot;,nil];</div><div class="line">	[alertView show];</div><div class="line"></div><div class="line">//在UIAlertViewDelegate中</div><div class="line">//支持直接跳转到AppStore的评论编辑页:通过在项目 URL 查询参数的最后加上 action=write-review 就可以跳转到 AppStore 并自动模态打开评论编辑页面。在此之前我们只能跳转到评论页。</div><div class="line">	NSURL *url = [NSURL URLWithString:@&quot;http://itunes.apple.com/WebObjects/MZStore.woa/wa/viewContentsUserReviews?id=1014844521&amp;pageNumber=0&amp;sortOrdering=2&amp;type=Purple+Software&amp;mt=8&amp;action=write-review&quot;];</div><div class="line">	if([[UIApplication sharedApplication] canOpenURL:url])&#123;</div><div class="line">        [[UIApplication sharedApplication] openURL:url];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>2.在页面中Modal出一个SKStoreProductViewController,用户在应用即可完成评分和评论  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#import &lt;StoreKit/StoreKit.h&gt;</div><div class="line"></div><div class="line">    SKStoreProductViewController *storeProductVC = [[SKStoreProductViewController alloc]init];</div><div class="line">    storeProductVC.delegate = self;</div><div class="line"></div><div class="line">    [storeProductVC loadProductWithParameters:@&#123;SKStoreProductParameterITunesItemIdentifier:@&quot;1014844521&quot;&#125; completionBlock:^(BOOL result, NSError * _Nullable error) &#123;</div><div class="line"></div><div class="line">        if (error) &#123;</div><div class="line">            NSLog(@&quot;%@&quot;,[error localizedDescription]);</div><div class="line">        &#125; else &#123;</div><div class="line">            NSLog(@&quot;加载完成&quot;);</div><div class="line">            [self presentViewController:storeProductVC animated:YES completion:^&#123;</div><div class="line">                NSLog(@&quot;界面弹出完成&quot;);</div><div class="line">            &#125;];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    //modal出来的页面点击&quot;取消&quot;的回调</div><div class="line">	- (void)productViewControllerDidFinish:(SKStoreProductViewController *)viewController&#123;</div><div class="line">    [self dismissViewControllerAnimated:YES completion:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>什么时候展示:<br>1.<a href="https://github.com/nicklockwood/iRate" target="_blank" rel="external">iRate</a>:提供了丰富的自定义弹出规则,之前我就是使用这个来做</p>
<p>2.服务器来控制弹出的时机</p>
<h4 id="iOS-10-3之后实现应用内评价的方法"><a href="#iOS-10-3之后实现应用内评价的方法" class="headerlink" title="iOS 10.3之后实现应用内评价的方法"></a><code>iOS 10.3之后</code>实现应用内评价的方法</h4><p><a href="https://developer.apple.com/app-store/ratings-and-reviews/" target="_blank" rel="external">官方文档看这里</a>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[SKStoreReviewController requestReview];</div></pre></td></tr></table></figure>
<p><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170619174141.png?imageView2/2/w/480/h/360/q/99|imageslim" alt="SamuelChan/20170619174141.png"></p>
<p>Feature:  </p>
<ol>
<li>只有评分,没有评论  </li>
<li>弹出完全由苹果控制,所以不能在手势/按钮点击回调中使用这个api,你并不知道有没有弹出  </li>
<li>每年只会弹出三次  </li>
<li>只会在最新版本中弹出,低版本调用了这个api也不会弹出  </li>
<li>在debug环境下,该框会一直弹出,TestFlight该方法无效</li>
<li>关闭:如下图<br><img src="http://ormqbgzmy.bkt.clouddn.com/SamuelChan/20170619221921.png?imageView2/2/w/360/h/200/q/99|imageslim" alt="SamuelChan/20170619221921.png"></li>
</ol>
<h3 id="我的方案"><a href="#我的方案" class="headerlink" title="我的方案"></a>我的方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> if ([UIDevice currentDevice].systemVersion.floatValue &gt;= 10.3) &#123;</div><div class="line">     [self inAppSKStoreReviewController];   </div><div class="line">  &#125;else&#123;</div><div class="line">//自定义弹出规则比如iRate,</div><div class="line">[[iRate shareInstance] logEvent:NO]</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>我从来都没有被弹出框引导去评价,都是直接关掉的;可以有了10.3的api又有多少产品经理会遵守呢…</li>
<li>这篇文章make no sense,只是用来练手的 哈哈</li>
</ol>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://sspai.com/post/38673" target="_blank" rel="external">具透丨iOS 10.3 新 App Store 评价机制详解</a><br><a href="https://9to5mac.com/2017/06/09/app-rating-custom-prompts-app-store-banned/" target="_blank" rel="external">App Store now requires developers to use official API to request app ratings, disallows custom prompts</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;应用评价&quot;&gt;&lt;a href=&quot;#应用评价&quot; class=&quot;headerlink&quot; title=&quot;应用评价&quot;&gt;&lt;/a&gt;应用评价&lt;/h2&gt;&lt;h3 id=&quot;summary&quot;&gt;&lt;a href=&quot;#summary&quot; class=&quot;headerlink&quot; title=&quot;sum
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
</feed>
